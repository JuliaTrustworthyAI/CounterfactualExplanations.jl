{
  "hash": "a11267883bfef916d21d9bbb7d95d6ec",
  "result": {
    "engine": "jupyter",
    "markdown": "---\nexecute: \n  output: true\n---\n\n``` @meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n# Parallelization\n\nVersion `0.1.15` adds support for parallelization through multi-processing. Currently, the only available backend for parallelization is [MPI.jl](https://juliaparallel.org/MPI.jl/latest/). \n\n## Available functions\n\nParallelization is only available for certain functions. To check if a function is parallelizable, you can use  `parallelizable` function:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nusing CounterfactualExplanations.Evaluation: evaluate, benchmark\nprintln(parallelizable(generate_counterfactual))\nprintln(parallelizable(evaluate))\nprintln(parallelizable(predict_label))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\ntrue\ntrue\nfalse\n```\n:::\n:::\n\n\nIn the following, we will generate multiple counterfactuals and evaluate them in parallel:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nchosen = rand(findall(predict_label(M, counterfactual_data) .== factual), 1000)\nxs = select_factual(counterfactual_data, chosen)\n```\n:::\n\n\n## Multi-threading\n\nWe first instantiate an `ThreadParallelizer` object:\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nparallelizer = ThreadsParallelizer()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nThreadsParallelizer()\n```\n:::\n:::\n\n\nTo generate counterfactuals in parallel, we use the `parallelize` function:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\nces = @with_parallelizer parallelizer begin\n    generate_counterfactual(\n        xs,\n        target,\n        counterfactual_data,\n        M,\n        generator\n    )\nend\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\rGenerating counterfactuals ...   0%|       |  ETA: 0:01:33 (92.85 ms/it)\rGenerating counterfactuals ... 100%|███████| Time: 0:00:01 ( 1.64 ms/it)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\n1000-element Vector{AbstractCounterfactualExplanation}:\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n ⋮\n CounterfactualExplanation\nConvergence: ✅ after 9 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n```\n:::\n:::\n\n\nTo evaluate counterfactuals in parallel, we again use the `parallelize` function:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\n@with_parallelizer parallelizer evaluate(ces)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\rEvaluating counterfactuals ...   0%|       |  ETA: 0:07:21 ( 0.44  s/it)\rEvaluating counterfactuals ... 100%|███████| Time: 0:00:00 ( 0.89 ms/it)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=7}\n```\n1000-element Vector{Any}:\n Vector[[1.0], Float32[3.2939816], [0.0]]\n Vector[[1.0], Float32[3.019046], [0.0]]\n Vector[[1.0], Float32[3.701171], [0.0]]\n Vector[[1.0], Float32[2.5611918], [0.0]]\n Vector[[1.0], Float32[2.9027307], [0.0]]\n Vector[[1.0], Float32[3.7893882], [0.0]]\n Vector[[1.0], Float32[3.5026522], [0.0]]\n Vector[[1.0], Float32[3.6317568], [0.0]]\n Vector[[1.0], Float32[3.084984], [0.0]]\n Vector[[1.0], Float32[3.2268934], [0.0]]\n Vector[[1.0], Float32[2.834947], [0.0]]\n Vector[[1.0], Float32[3.656587], [0.0]]\n Vector[[1.0], Float32[2.5985842], [0.0]]\n ⋮\n Vector[[1.0], Float32[4.067538], [0.0]]\n Vector[[1.0], Float32[3.02231], [0.0]]\n Vector[[1.0], Float32[2.748292], [0.0]]\n Vector[[1.0], Float32[2.9483426], [0.0]]\n Vector[[1.0], Float32[3.066149], [0.0]]\n Vector[[1.0], Float32[3.6018147], [0.0]]\n Vector[[1.0], Float32[3.0138078], [0.0]]\n Vector[[1.0], Float32[3.5724509], [0.0]]\n Vector[[1.0], Float32[3.117551], [0.0]]\n Vector[[1.0], Float32[2.9670508], [0.0]]\n Vector[[1.0], Float32[3.4107168], [0.0]]\n Vector[[1.0], Float32[3.0252533], [0.0]]\n```\n:::\n:::\n\n\nBenchmarks can also be run with parallelization by specifying `parallelizer` argument:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\n# Models:\nbmk = benchmark(counterfactual_data; parallelizer = parallelizer)\n```\n:::\n\n\n## MPI\n\n\n```{=commonmark}\n!!! note\n    To use MPI, you need to have MPI installed on your machine. Running the following code straight from a running Julia session will work if you have MPI installed on your machine, but it will be run on a single process. To execute the code on multiple processes, you need to run it from the command line with `mpirun` or `mpiexec`. For example, to run a script on 4 processes, you can run the following command from the command line:\n    \n    ```\n\n    mpiexecjl --project -n 4 julia -e 'include(\"docs/src/srcipts/mpi.jl\")'\n    ```\n\n    For more information, see [MPI.jl](https://juliaparallel.org/MPI.jl/latest/). \n```\n\nWe first instantiate an `MPIParallelizer` object:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\nimport MPI\nMPI.Init()\nparallelizer = MPIParallelizer(MPI.COMM_WORLD; threaded=true)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nPrecompiling MPIExt\n  ✓ TaijaParallel → MPIExt\n  1 dependency successfully precompiled in 3 seconds. 255 already precompiled.\n[ Info: Precompiling MPIExt [48137b38-b316-530b-be8a-261f41e68c23]\n┌ Warning: Module TaijaParallel with build ID ffffffff-ffff-ffff-0000-abca70332c61 is missing from the cache.\n│ This may mean TaijaParallel [bf1c2c22-5e42-4e78-8b6b-92e6c673eeb0] does not support precompilation but is imported by a module that does.\n└ @ Base loading.jl:1948\n[ Info: Skipping precompilation since __precompile__(false). Importing MPIExt [48137b38-b316-530b-be8a-261f41e68c23].\n[ Info: Using `MPI.jl` for multi-processing.\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nRunning on 1 processes.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\nMPIExt.MPIParallelizer(MPI.Comm(1140850688), 0, 1, nothing, true)\n```\n:::\n:::\n\n\nTo generate counterfactuals in parallel, we use the `parallelize` function:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nces = @with_parallelizer parallelizer begin\n    generate_counterfactual(\n        xs,\n        target,\n        counterfactual_data,\n        M,\n        generator\n    )\nend\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\rGenerating counterfactuals ...   8%|▋      |  ETA: 0:00:01 ( 1.19 ms/it)\rGenerating counterfactuals ...  19%|█▎     |  ETA: 0:00:01 ( 1.08 ms/it)\rGenerating counterfactuals ...  29%|██     |  ETA: 0:00:01 ( 1.07 ms/it)\rGenerating counterfactuals ...  38%|██▋    |  ETA: 0:00:01 ( 1.12 ms/it)\rGenerating counterfactuals ...  48%|███▍   |  ETA: 0:00:01 ( 1.10 ms/it)\rGenerating counterfactuals ...  58%|████   |  ETA: 0:00:00 ( 1.09 ms/it)\rGenerating counterfactuals ...  68%|████▊  |  ETA: 0:00:00 ( 1.11 ms/it)\rGenerating counterfactuals ...  78%|█████▌ |  ETA: 0:00:00 ( 1.09 ms/it)\rGenerating counterfactuals ...  88%|██████▏|  ETA: 0:00:00 ( 1.08 ms/it)\rGenerating counterfactuals ...  98%|██████▉|  ETA: 0:00:00 ( 1.07 ms/it)\rGenerating counterfactuals ... 100%|███████| Time: 0:00:01 ( 1.07 ms/it)\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=9}\n```\n1000-element Vector{AbstractCounterfactualExplanation}:\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n ⋮\n CounterfactualExplanation\nConvergence: ✅ after 9 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 6 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 8 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n CounterfactualExplanation\nConvergence: ✅ after 7 steps.\n```\n:::\n:::\n\n\nTo evaluate counterfactuals in parallel, we again use the `parallelize` function:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\n@with_parallelizer parallelizer evaluate(ces)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n1000-element Vector{Any}:\n Vector[[1.0], Float32[3.0941274], [0.0]]\n Vector[[1.0], Float32[3.0894346], [0.0]]\n Vector[[1.0], Float32[3.5737448], [0.0]]\n Vector[[1.0], Float32[2.6201036], [0.0]]\n Vector[[1.0], Float32[2.8519764], [0.0]]\n Vector[[1.0], Float32[3.7762523], [0.0]]\n Vector[[1.0], Float32[3.4162796], [0.0]]\n Vector[[1.0], Float32[3.6095932], [0.0]]\n Vector[[1.0], Float32[3.1347957], [0.0]]\n Vector[[1.0], Float32[3.0313473], [0.0]]\n Vector[[1.0], Float32[2.7612567], [0.0]]\n Vector[[1.0], Float32[3.6191392], [0.0]]\n Vector[[1.0], Float32[2.610616], [0.0]]\n ⋮\n Vector[[1.0], Float32[4.0844703], [0.0]]\n Vector[[1.0], Float32[3.0119], [0.0]]\n Vector[[1.0], Float32[2.4461186], [0.0]]\n Vector[[1.0], Float32[3.071967], [0.0]]\n Vector[[1.0], Float32[3.132917], [0.0]]\n Vector[[1.0], Float32[3.5403214], [0.0]]\n Vector[[1.0], Float32[3.0588162], [0.0]]\n Vector[[1.0], Float32[3.5600657], [0.0]]\n Vector[[1.0], Float32[3.2205954], [0.0]]\n Vector[[1.0], Float32[2.896302], [0.0]]\n Vector[[1.0], Float32[3.2603998], [0.0]]\n Vector[[1.0], Float32[3.1369917], [0.0]]\n```\n:::\n:::\n\n\n```{=commonmark}\n!!! tip\n    Note that parallelizable processes can be supplied as input to the macro either as a block or directly as an expression.\n```\n\n\nBenchmarks can also be run with parallelization by specifying `parallelizer` argument:\n\n::: {.cell execution_count=11}\n``` {.julia .cell-code}\n# Models:\nbmk = benchmark(counterfactual_data; parallelizer = parallelizer)\n```\n:::\n\n\nThe following code snippet shows a complete example script that uses MPI for running a benchmark in parallel:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\nusing CounterfactualExplanations\nusing CounterfactualExplanations.Evaluation: benchmark\nusing CounterfactualExplanations.Models\nimport MPI\n\nMPI.Init()\n\ndata = TaijaData.load_linearly_separable()\ncounterfactual_data = DataPreprocessing.CounterfactualData(data...)\nM = fit_model(counterfactual_data, :Linear)\nfactual = 1\ntarget = 2\nchosen = rand(findall(predict_label(M, counterfactual_data) .== factual), 100)\nxs = select_factual(counterfactual_data, chosen)\ngenerator = GenericGenerator()\n\nparallelizer = MPIParallelizer(MPI.COMM_WORLD)\n\nbmk = benchmark(counterfactual_data; parallelizer=parallelizer)\n\nMPI.Finalize()\n```\n:::\n\n\nThe file can be executed from the command line as follows:\n\n```\nmpiexecjl --project -n 4 julia -e 'include(\"docs/src/srcipts/mpi.jl\")'\n```\n\n",
    "supporting": [
      "parallelization_files"
    ],
    "filters": []
  }
}