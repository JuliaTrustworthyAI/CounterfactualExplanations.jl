{
  "hash": "62a87dcaa5b382bfa1227ce68e6a2932",
  "result": {
    "markdown": "---\ntitle: Data Catalogue\n---\n\n\n```@meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n\nTo allow researchers and practitioners to test and compare counterfactual generators, the package ships with pre-processed synthetic and real-world benchmark datasets from different domains.\n\n## Synthetic Data\n\nThe following dictionary can be used to inspect the available methods to generate synthetic datasets where the `key` indicates the name of the data and the `value` is the corresponding method:\n\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ndata_catalogue[:synthetic]\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```\nDict{Symbol, Function} with 6 entries:\n  :overlapping        => load_overlapping\n  :linearly_separable => load_linearly_separable\n  :blobs              => load_blobs\n  :moons              => load_moons\n  :circles            => load_circles\n  :multi_class        => load_multi_class\n```\n:::\n:::\n\n\nThe chart below shows the generated data using default parameters:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\nplts = []\n_height = 200\n_n = length(keys(data_catalogue[:synthetic]))\nfor (key, fun) in data_catalogue[:synthetic]\n    counterfactual_data = fun()\n    plt = plot()\n    scatter!(counterfactual_data, title=key)\n    plts = [plts..., plt]\nend\nplot(plts..., size=(_n * _height, _height), layout=(1, _n))\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](data_catalogue_files/figure-commonmark/cell-4-output-1.svg){}\n:::\n:::\n\n\n## Real-World Data\n\nAs for real-world data, the same dictionary can be used to inspect the available data from different domains. \n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\ndata_catalogue[:tabular]\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nDict{Symbol, Function} with 5 entries:\n  :german_credit      => load_german_credit\n  :california_housing => load_california_housing\n  :credit_default     => load_credit_default\n  :adult              => load_uci_adult\n  :gmsc               => load_gmsc\n```\n:::\n:::\n\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\ndata_catalogue[:vision]\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```\nDict{Symbol, Function} with 3 entries:\n  :fashion_mnist => load_fashion_mnist\n  :mnist         => load_mnist\n  :cifar_10      => load_cifar_10\n```\n:::\n:::\n\n\n## Loading Data\n\nTo load or generate any of the datasets listed above, you can just use the corresponding method, for example:\n\n::: {.cell execution_count=6}\n``` {.julia .cell-code}\ncounterfactual_data = load_linearly_separable()\n```\n:::\n\n\nOptionally, you can specify how many samples you want to generate like so:\n\n::: {.cell execution_count=7}\n``` {.julia .cell-code}\nn = 100\ncounterfactual_data = load_overlapping(n)\n```\n:::\n\n\nThis also applies to real-world datasets, which by default are loaded in their entirety. If `n` is supplied, the dataset will be randomly undersampled:\n\n::: {.cell execution_count=8}\n``` {.julia .cell-code}\ncounterfactual_data = load_mnist(n)\n```\n:::\n\n\nThe undersampled dataset is automatically balanced:\n\n::: {.cell execution_count=9}\n``` {.julia .cell-code}\nsum(counterfactual_data.y; dims=2)\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n```\n10Ã—1 Matrix{Int64}:\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n 10\n```\n:::\n:::\n\n\nWe can also use a helper function to split the data into train and test sets:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ntrain_data, test_data = \n    CounterfactualExplanations.DataPreprocessing.train_test_split(counterfactual_data)\n```\n:::\n\n\n",
    "supporting": [
      "data_catalogue_files"
    ],
    "filters": []
  }
}