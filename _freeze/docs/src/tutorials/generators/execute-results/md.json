{
  "hash": "5c8bc2c9c00c2e797a3e1b1be8bdc271",
  "result": {
    "engine": "jupyter",
    "markdown": "```@meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n# Handling Generators\n\nGenerating Counterfactual Explanations can be seen as a generative modelling task because it involves generating samples in the input space: $x \\sim \\mathcal{X}$. In this tutorial, we will introduce how Counterfactual `GradientBasedGenerator`s are used. They are discussed in more detail in the explanatory section of the documentation.\n\n## Composable Generators \n\n\n```{=commonmark}\n!!! warning \"Breaking Changes Expected\"\n    Work on this feature is still in its very early stages and breaking changes should be expected. \n```\n\n\nOne of the key objectives for this package is **Composability**. It turns out that many of the various counterfactual generators that have been proposed in the literature, essentially do the same thing: they optimize an objective function. Formally we have,\n\n$$\n\\begin{aligned}\n\\mathbf{s}^\\prime &= \\arg \\min_{\\mathbf{s}^\\prime \\in \\mathcal{S}} \\left\\{  {\\text{yloss}(M(f(\\mathbf{s}^\\prime)),y^*)}+ \\lambda {\\text{cost}(f(\\mathbf{s}^\\prime)) }  \\right\\} \n\\end{aligned} \n$$ {#eq-general}\n\nwhere $\\text{yloss}$ denotes the main loss function and $\\text{cost}$ is a penalty term [@altmeyer2023endogenous]. \n\nWithout going into further detail here, the important thing to mention is that @eq-general very closely describes how counterfactual search is actually implemented in the package. In other words, all off-the-shelf generators currently implemented work with that same objective. They just vary in the way that penalties are defined, for example. This gives rise to an interesting idea: \n\n> Why not compose generators that combine ideas from different off-the-shelf generators?\n\nThe [`GradientBasedGenerator`](@ref) class provides a straightforward way to do this, without requiring users to build custom `GradientBasedGenerator`s from scratch. It can be instantiated as follows:\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\ngenerator = GradientBasedGenerator()\n```\n:::\n\n\nBy default, this creates a `generator` that simply performs gradient descent without any penalties. To modify the behaviour of the `generator`, you can define the counterfactual search objective function using the [`@objective`](@ref) macro:\n\n::: {.cell execution_count=3}\n``` {.julia .cell-code}\n@objective(generator, logitbinarycrossentropy + 0.1distance_l2 + 1.0ddp_diversity)\n```\n:::\n\n\nHere we have essentially created a version of the [`DiCEGenerator`](@ref):\n\n::: {.cell execution_count=4}\n``` {.julia .cell-code}\nce = generate_counterfactual(x, target, counterfactual_data, M, generator; num_counterfactuals=5)\nplot(ce)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n![](generators_files/figure-commonmark/cell-5-output-1.svg){}\n:::\n:::\n\n\nMultiple macros can be chained using `Chains.jl` making it easy to create entirely new flavours of counterfactual generators. The following generator, for example, combines ideas from DiCE [@mothilal2020explaining] and REVISE [@joshi2019realistic]:\n\n::: {.cell execution_count=5}\n``` {.julia .cell-code}\n@chain generator begin\n    @objective logitcrossentropy + 1.0ddp_diversity     # DiCE (Mothilal et al. 2020)\n    @with_optimiser Flux.Adam(0.1)                      \n    @search_latent_space                                # REVISE (Joshi et al. 2019)\nend\n```\n:::\n\n\n\n\n\n\n::: {.cell execution_count=8}\n\n::: {.cell-output .cell-output-display .cell-output-markdown execution_count=9}\nLet's take this generator to our MNIST dataset and generate a counterfactual explanation for turning a 0 into a 8. \n\n:::\n:::\n\n\n::: {.cell execution_count=9}\n\n::: {.cell-output .cell-output-display}\n![](generators_files/figure-commonmark/cell-10-output-1.svg){}\n:::\n:::\n\n\n## Off-the-Shelf Generators \n\nOff-the-shelf generators are just default recipes for counterfactual generators. Currently, the following off-the-shelf counterfactual generators are implemented in the package:\n\n::: {.cell execution_count=10}\n``` {.julia .cell-code}\ngenerator_catalogue\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n```\nDict{Symbol, Any} with 11 entries:\n  :gravitational   => GravitationalGenerator\n  :growing_spheres => GrowingSpheresGenerator\n  :revise          => REVISEGenerator\n  :clue            => CLUEGenerator\n  :probe           => ProbeGenerator\n  :dice            => DiCEGenerator\n  :feature_tweak   => FeatureTweakGenerator\n  :claproar        => ClaPROARGenerator\n  :wachter         => WachterGenerator\n  :generic         => GenericGenerator\n  :greedy          => GreedyGenerator\n```\n:::\n:::\n\n\n\n\nTo specify the type of generator you want to use, you can simply instantiate it:\n\n::: {.cell execution_count=12}\n``` {.julia .cell-code}\n# Search:\ngenerator = GenericGenerator()\nce = generate_counterfactual(x, target, counterfactual_data, M, generator)\nplot(ce)\n```\n\n::: {.cell-output .cell-output-display execution_count=13}\n![](generators_files/figure-commonmark/cell-13-output-1.svg){}\n:::\n:::\n\n\nWe generally make an effort to follow the literature as closely as possible when implementing off-the-shelf generators. \n\n## References\n\n",
    "supporting": [
      "generators_files"
    ],
    "filters": []
  }
}