{
  "hash": "667b4b632b831e403cb7d6261ed31019",
  "result": {
    "engine": "jupyter",
    "markdown": "```@meta\nCurrentModule = CounterfactualExplanations \n```\n\n\n\n# `ProbeGenerator`\n\nThe `ProbeGenerator` is designed to navigate the trade-offs between costs and robustness in Algorithmic Recourse [@pawelczyk2022probabilistically].\n\n## Description\n\nThe goal of ProbeGenerator is to find a recourse x' whose prediction at any point y within some set around x' belongs to the positive class with probability 1 - r, where r is the recourse invalidation rate. It minimizes the gap between the achieved and desired recourse invalidation rates, minimizes recourse costs, and also ensures that the resulting recourse achieves a positive model prediction.\n\n### Explanation\n\nThe loss function this generator is defined below. R is a hinge loss parameter which helps control for robustness. The loss and penalty functions can still be chosen freely.\n\n``` math\n\\begin{aligned}\nR(x'; \\sigma^2 I) + l(f(x'), s) + \\lambda d_c(x', x)\n\\end{aligned}\n```\n\nR uses the following formula to control for noise. It generates small perturbations and checks how often the counterfactual explanation flips back to a factual one, when small amounts of noise are added to it.\n\n``` math\n\\begin{aligned}\n\\Delta(x^{\\hat{E}}) &= E_{\\varepsilon}[h(x^{\\hat{E}}) - h(x^{\\hat{E}} + \\varepsilon)]\n\\end{aligned}\n```\n\nThe above formula is not differentiable. For this reason the generator uses the closed form version of the formula below.\n\n``` math\n\\begin{equation}\n\\Delta \\tilde{}(x^{\\hat{E}}, \\sigma^2 I) = 1 - \\Phi \\left(\\frac{\\sqrt{f(x^{\\hat{E}})}}{\\sqrt{\\nabla f(x^{\\hat{E}})^T \\sigma^2 I \\nabla f(x^{\\hat{E}})}}\\right) \n\\end{equation}\n```\n\n### Usage\n\nGenerating a counterfactual with the data loaded and generator chosen works as follows:\n\nNote: It is important to set the convergence to \":invalidation_rate\" here.\n\n::: {.cell execution_count=2}\n``` {.julia .cell-code}\nM = fit_model(counterfactual_data, :DeepEnsemble)\nopt = Descent(0.01)\ngenerator = CounterfactualExplanations.Generators.ProbeGenerator(opt=opt)\nconv = CounterfactualExplanations.Convergence.InvalidationRateConvergence(;invalidation_rate=0.5)\nce = generate_counterfactual(x, target, counterfactual_data, M, generator, convergence=conv)\nplot(ce)\n```\n:::\n\n\nChoosing different invalidation rates makes the counterfactual more or less robust. The following plot shows the counterfactuals generated for different invalidation rates.\n\n::: {.cell execution_count=3}\n\n::: {.cell-output .cell-output-display execution_count=4}\n![](probe_files/figure-commonmark/cell-4-output-1.svg){}\n:::\n:::\n\n\n## References\n\n",
    "supporting": [
      "probe_files"
    ],
    "filters": []
  }
}