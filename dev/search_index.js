var documenterSearchIndex = {"docs":
[{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/quick/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/reference/#All-functions-and-types","page":"Full references","title":"All functions and types","text":"","category":"section"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"","category":"page"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = true","category":"page"},{"location":"reference/reference/#AlgorithmicRecourse.Recourse","page":"Full references","title":"AlgorithmicRecourse.Recourse","text":"Recourse(x̲::AbstractArray, y̲::Float64, path::Matrix{Float64}, generator::Generators.Generator, 𝓘::AbstractArray, x̅::AbstractArray, y̅::Float64, 𝓜::Models.FittedModel, target::Float64)\n\nCollects all variables relevant to the recourse outcome. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.threshold_reached-Tuple{AlgorithmicRecourse.Models.FittedModel, AbstractArray, Float64, Float64}","page":"Full references","title":"AlgorithmicRecourse.threshold_reached","text":"threshold_reached(𝓜::Models.FittedModel, x̲::AbstractArray, target::Float64, γ::Float64)\n\nChecks if confidence threshold has been reached. \n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.BayesianLogisticModel","page":"Full references","title":"AlgorithmicRecourse.Models.BayesianLogisticModel","text":"BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates μ (coefficients including constant term(s)) and Σ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\n\nSee also:\n\nlogits(𝓜::BayesianLogisticModel, X::AbstractArray)\nprobs(𝓜::BayesianLogisticModel, X::AbstractArray)\nconfidence(𝓜::BayesianLogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.Models.LogisticModel","page":"Full references","title":"AlgorithmicRecourse.Models.LogisticModel","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\n\nSee also: \n\nlogits(𝓜::LogisticModel, X::AbstractArray)\nprobs(𝓜::LogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝓜::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as [1 X]μ.\n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nlogits(𝓜, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝓜::LogisticModel, X::AbstractArray)\n\nComputes logits as Xw+b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nlogits(𝓜, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝓜::BayesianLogisticModel, X::AbstractArray)\n\nComputes predictive probabilities using a Probit approximation. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nprobs(𝓜, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝓜::LogisticModel, X::AbstractArray)\n\nComputes predictive probabilities from logits as σ(Xw+b) where 'σ' is the sigmoid function. \n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nprobs(𝓜, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmicRecourse","category":"page"},{"location":"#AlgorithmicRecourse","page":"Home","title":"AlgorithmicRecourse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AlgorithmicRecourse.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for counterfactual explanations (CE) and algorithmic recourse (AR) in Julia. The former (CE) is a common approach towards explaining machine learning models. The latter (AR) uses counterfactual explanations to systematically provide recourse to individuals faced with an undesirable algorithmic outcome. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/AlgorithmicRecourse.jl\")","category":"page"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/exported/#Exported-functions-and-types","page":"Exported","title":"Exported functions and types","text":"","category":"section"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"Private = false","category":"page"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = false","category":"page"},{"location":"reference/exported/#AlgorithmicRecourse.generate_recourse-Tuple{Generator, AbstractArray, AlgorithmicRecourse.Models.FittedModel, Float64, Float64}","page":"Exported","title":"AlgorithmicRecourse.generate_recourse","text":"generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64, γ::Float64; T=1000, 𝓘=[])\n\nTakes a recourse generator, the factual sample x̅, the fitted model 𝓜, the target label and its desired threshold probability γ. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generators\n\nw = [1.0,-2.0] # true coefficients\nb = [0]\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\nγ = 0.9\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, x̅, 𝓜, target, γ); # generate recourse\n\nGreedy generator for Bayesian model\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\nγ = 0.9\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, x̅, 𝓜, target, γ); # generate recourse\n\nSee also GenericGenerator(λ::Float64, ϵ::Float64, τ::Float64, loss::Symbol), GreedyGenerator(Γ::Float64, δ::Float64, n::Int64, loss::Symbol).\n\n\n\n\n\n","category":"method"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.Generator","page":"Exported","title":"AlgorithmicRecourse.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.GenericGenerator","page":"Exported","title":"AlgorithmicRecourse.Generators.GenericGenerator","text":"GenericGenerator(λ::Float64, ϵ::Float64, τ::Float64, loss::Symbol)\n\nA constructor for a generic recourse generator.  It takes values for the complexity penalty λ, the learning rate ϵ, the tolerance for convergence τ and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64; T=1000, 𝓘=[]).\n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.GreedyGenerator","page":"Exported","title":"AlgorithmicRecourse.Generators.GreedyGenerator","text":"GreedyGenerator(δ::Float64, n::Int64, loss::Symbol)\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the perturbation size δ, the maximum number of times n that any feature can be changed  and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64; T=1000, 𝓘=[]).\n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Losses.hinge_loss-Tuple{Any, Any}","page":"Exported","title":"AlgorithmicRecourse.Losses.hinge_loss","text":"hinge_loss(ŷ, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"}]
}
