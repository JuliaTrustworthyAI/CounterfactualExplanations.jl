var documenterSearchIndex = {"docs":
[{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/quick/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"","category":"page"},{"location":"exported/","page":"Exports","title":"Exports","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"exported/#Exported-functions-and-types","page":"Exports","title":"Exported functions and types","text":"","category":"section"},{"location":"exported/","page":"Exports","title":"Exports","text":"","category":"page"},{"location":"exported/","page":"Exports","title":"Exports","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = false","category":"page"},{"location":"exported/#AlgorithmicRecourse.generate_recourse-Tuple{Generator, AbstractArray, AlgorithmicRecourse.Models.FittedModel, Float64}","page":"Exports","title":"AlgorithmicRecourse.generate_recourse","text":"generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64; T=1000, 𝓘=[])\n\nTakes a recourse generator, the factual sample x̅, the fitted model 𝓜 and the target label. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generators\n\nw = [1.0,-2.0] # true coefficients\nb = [0]\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, x̅, 𝓜, target); # generate recourse\n\nGreedy generator for Bayesian model\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\ngenerator = GreedyGenerator(0.95,0.01,20,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, x̅, 𝓜, target); # generate recourse\n\nSee also GenericGenerator(λ::Float64, ϵ::Float64, τ::Float64), GreedyGenerator(Γ::Float64, δ::Float64, n::Int64, loss::Symbol).\n\n\n\n\n\n","category":"method"},{"location":"exported/#AlgorithmicRecourse.Generators.Generator","page":"Exports","title":"AlgorithmicRecourse.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Generators.GenericGenerator","page":"Exports","title":"AlgorithmicRecourse.Generators.GenericGenerator","text":"GenericGenerator(λ::Float64, ϵ::Float64, τ::Float64, loss::Symbol)\n\nA constructor for a generic recourse generator.  It takes values for the complexity penalty λ, the learning rate ϵ, the tolerance for convergence τ and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64; T=1000, 𝓘=[]).\n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Generators.GreedyGenerator","page":"Exports","title":"AlgorithmicRecourse.Generators.GreedyGenerator","text":"GreedyGenerator(Γ::Float64, δ::Float64, n::Int64, loss::Symbol)\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the desired level of confidence Γ, the perturbation size δ, the maximum number of times n that any feature can be changed  and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GreedyGenerator(0.95,0.01,20,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, x̅::AbstractArray, 𝓜::Models.FittedModel, target::Float64; T=1000, 𝓘=[]).\n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Losses.hinge_loss-Tuple{Any, Any}","page":"Exports","title":"AlgorithmicRecourse.Losses.hinge_loss","text":"hinge_loss(ŷ, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/#Complete-reference","page":"Reference","title":"Complete reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = true","category":"page"},{"location":"reference/#AlgorithmicRecourse.Recourse","page":"Reference","title":"AlgorithmicRecourse.Recourse","text":"Recourse(\n    x̲::AbstractArray\n    y̲::Float64\n    path::Matrix{Float64}\n    generator::Generators.Generator\n    𝓘::AbstractArray\n    x̅::AbstractArray\n    y̅::Float64\n    𝓜::Models.FittedModel\n    target::Float64\n)\n\nCollects all variables relevant to the recourse outcome.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.BayesianLogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.BayesianLogisticModel","text":"BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates μ (coefficients including constant term(s)) and Σ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\n\nSee also logits(𝓜::BayesianLogisticModel, X::AbstractArray), probs(𝓜::BayesianLogisticModel, X::AbstractArray).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.LogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.LogisticModel","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\n\nSee also logits(𝓜::LogisticModel, X::AbstractArray), probs(𝓜::LogisticModel, X::AbstractArray).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.confidence-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.confidence","text":"confidence(𝓜::BayesianLogisticModel, X::AbstractArray)\n\nComputes the confidence (posterior predictive) using a Probit approximation. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nconfidence(𝓜, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝓜::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as [1 X]μ.\n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nlogits(𝓜, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝓜::LogisticModel, X::AbstractArray)\n\nComputes logits as Xw+b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nlogits(𝓜, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝓜::BayesianLogisticModel, X::AbstractArray)\n\nComputes probabilities from logits as σ([1 X]μ) where 'σ' is the sigmoid function. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝓜 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nprobs(𝓜, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝓜::LogisticModel, X::AbstractArray)\n\nComputes probabilities from logits as σ(Xw+b) where 'σ' is the sigmoid function. \n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝓜 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nprobs(𝓜, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmicRecourse","category":"page"},{"location":"#AlgorithmicRecourse","page":"Home","title":"AlgorithmicRecourse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AlgorithmicRecourse.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for counterfactual explanations (CE) and algorithmic recourse (AR) in Julia. The former (CE) is a common approach towards explaining machine learning models. The latter (AR) uses counterfactual explanations to systematically provide recourse to individuals faced with an undesirable algorithmic outcome. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/AlgorithmicRecourse.jl\")","category":"page"}]
}
