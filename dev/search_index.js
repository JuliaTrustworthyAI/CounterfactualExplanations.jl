var documenterSearchIndex = {"docs":
[{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/quick/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"","category":"page"},{"location":"exported/","page":"Exports","title":"Exports","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"exported/#Exported-functions-and-types","page":"Exports","title":"Exported functions and types","text":"","category":"section"},{"location":"exported/","page":"Exports","title":"Exports","text":"","category":"page"},{"location":"exported/","page":"Exports","title":"Exports","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = false","category":"page"},{"location":"exported/#AlgorithmicRecourse.generate_recourse-Tuple{Generator, AbstractArray, AlgorithmicRecourse.Models.FittedModel, Float64}","page":"Exports","title":"AlgorithmicRecourse.generate_recourse","text":"generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64; T=1000, ğ“˜=[])\n\nTakes a recourse generator, the factual sample xÌ…, the fitted model ğ“œ and the target label. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generators\n\nw = [1.0,-2.0] # true coefficients\nb = [0]\nxÌ… = reshape([-1,0.5],1,2)\ntarget = 1.0\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, xÌ…, ğ“œ, target); # generate recourse\n\nGreedy generator for Bayesian model\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nxÌ… = reshape([-1,0.5],1,2)\ntarget = 1.0\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\ngenerator = GreedyGenerator(0.95,0.01,20,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, xÌ…, ğ“œ, target); # generate recourse\n\nSee also GenericGenerator(Î»::Float64, Ïµ::Float64, Ï„::Float64), GreedyGenerator(Î“::Float64, Î´::Float64, n::Int64, loss::Symbol).\n\n\n\n\n\n","category":"method"},{"location":"exported/#AlgorithmicRecourse.Generators.Generator","page":"Exports","title":"AlgorithmicRecourse.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Generators.GenericGenerator","page":"Exports","title":"AlgorithmicRecourse.Generators.GenericGenerator","text":"GenericGenerator(Î»::Float64, Ïµ::Float64, Ï„::Float64, loss::Symbol)\n\nA constructor for a generic recourse generator.  It takes values for the complexity penalty Î», the learning rate Ïµ, the tolerance for convergence Ï„ and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64; T=1000, ğ“˜=[]).\n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Generators.GreedyGenerator","page":"Exports","title":"AlgorithmicRecourse.Generators.GreedyGenerator","text":"GreedyGenerator(Î“::Float64, Î´::Float64, n::Int64, loss::Symbol)\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the desired level of confidence Î“, the perturbation size Î´, the maximum number of times n that any feature can be changed  and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GreedyGenerator(0.95,0.01,20,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64; T=1000, ğ“˜=[]).\n\n\n\n\n\n","category":"type"},{"location":"exported/#AlgorithmicRecourse.Losses.hinge_loss-Tuple{Any, Any}","page":"Exports","title":"AlgorithmicRecourse.Losses.hinge_loss","text":"hinge_loss(yÌ‚, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/#Complete-reference","page":"Reference","title":"Complete reference","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = true","category":"page"},{"location":"reference/#AlgorithmicRecourse.Recourse","page":"Reference","title":"AlgorithmicRecourse.Recourse","text":"Recourse(\n    xÌ²::AbstractArray\n    yÌ²::Float64\n    path::Matrix{Float64}\n    generator::Generators.Generator\n    ğ“˜::AbstractArray\n    xÌ…::AbstractArray\n    yÌ…::Float64\n    ğ“œ::Models.FittedModel\n    target::Float64\n)\n\nCollects all variables relevant to the recourse outcome.\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.BayesianLogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.BayesianLogisticModel","text":"BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates Î¼ (coefficients including constant term(s)) and Î£ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\n\nSee also logits(ğ“œ::BayesianLogisticModel, X::AbstractArray), probs(ğ“œ::BayesianLogisticModel, X::AbstractArray).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.LogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.LogisticModel","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\n\nSee also logits(ğ“œ::LogisticModel, X::AbstractArray), probs(ğ“œ::LogisticModel, X::AbstractArray).\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.confidence-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.confidence","text":"confidence(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\nComputes the confidence (posterior predictive) using a Probit approximation. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\nx = reshape([1,1],1,2)\nconfidence(ğ“œ, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as [1 X]Î¼.\n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\nx = reshape([1,1],1,2)\nlogits(ğ“œ, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(ğ“œ::LogisticModel, X::AbstractArray)\n\nComputes logits as Xw+b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nlogits(ğ“œ, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\nComputes probabilities from logits as Ïƒ([1 X]Î¼) where 'Ïƒ' is the sigmoid function. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\nx = reshape([1,1],1,2)\nprobs(ğ“œ, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(ğ“œ::LogisticModel, X::AbstractArray)\n\nComputes probabilities from logits as Ïƒ(Xw+b) where 'Ïƒ' is the sigmoid function. \n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nprobs(ğ“œ, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmicRecourse","category":"page"},{"location":"#AlgorithmicRecourse","page":"Home","title":"AlgorithmicRecourse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AlgorithmicRecourse.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for counterfactual explanations (CE) and algorithmic recourse (AR) in Julia. The former (CE) is a common approach towards explaining machine learning models. The latter (AR) uses counterfactual explanations to systematically provide recourse to individuals faced with an undesirable algorithmic outcome. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/AlgorithmicRecourse.jl\")","category":"page"}]
}
