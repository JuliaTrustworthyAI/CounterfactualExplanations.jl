var documenterSearchIndex = {"docs":
[{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"tutorials/multi/#Recourse-for-multi-class-targets","page":"Multi-class target","title":"Recourse for multi-class targets","text":"","category":"section"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"using Flux, Random, Plots, PlotThemes, CounterfactualExplanations, Statistics\ntheme(:wong)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"LogLevel(1)","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"x, y = toy_data_multi()\nX = hcat(x...)\ny_train = Flux.onehotbatch(y, unique(y))\ny_train = Flux.unstack(y_train',1)\nplt = plot()\nplt = plot_data!(plt,X',y);\nsavefig(plt, \"www/multi_samples.png\")","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"tutorials/multi/#Classifier","page":"Multi-class target","title":"Classifier","text":"","category":"section"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"n_hidden = 32\nout_dim = length(unique(y))\nkw = (output_dim=out_dim, dropout=true)\nnn = build_model(;kw...)\nloss(x, y) = Flux.Losses.logitcrossentropy(nn(x), y)\nps = Flux.params(nn)\ndata = zip(x,y_train);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"using Flux.Optimise: update!, ADAM\nopt = ADAM()\nepochs = 10\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, params(nn), gs)\n  end\n  if epoch % show_every == 0\n    println(\"Epoch \" * string(epoch))\n    @show avg_loss(data)\n  end\nend","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"Epoch 1\navg_loss(data) = 0.9255239012607264\nEpoch 2\navg_loss(data) = 0.3593051233387213\nEpoch 3\navg_loss(data) = 0.18421732400655624\nEpoch 4\navg_loss(data) = 0.10711486082055025\nEpoch 5\navg_loss(data) = 0.07511142481836484\nEpoch 6\navg_loss(data) = 0.0575109613420611\nEpoch 7\navg_loss(data) = 0.0424017922374355\nEpoch 8\navg_loss(data) = 0.03331096899975358\nEpoch 9\navg_loss(data) = 0.027016712426665555\nEpoch 10\navg_loss(data) = 0.02219848870252177","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"using CounterfactualExplanations, CounterfactualExplanations.Models\nimport CounterfactualExplanations.Models: logits, probs # import functions in order to extend\n\n# Step 1)\nstruct NeuralNetwork <: Models.FittedModel\n    nn::Any\nend\n\n# Step 2)\nlogits(ùë¥::NeuralNetwork, X::AbstractArray) = ùë¥.nn(X)\nprobs(ùë¥::NeuralNetwork, X::AbstractArray)= softmax(logits(ùë¥, X))\nùë¥ = NeuralNetwork(nn);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"plt = plot_contour_multi(X',y,ùë¥);\nsavefig(plt, \"www/multi_contour.png\")","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"# Randomly selected factual:\nRandom.seed!(42);\nxÃÖ = X[:,rand(1:size(X)[2])]\nyÃÖ = Flux.onecold(probs(ùë¥, xÃÖ),unique(y))\ntarget = rand(unique(y)[1:end .!= yÃÖ]) # opposite label as target\nŒ≥ = 0.75\n# Define Generator:\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitcrossentropy,nothing)\n# Generate recourse:\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"MLP\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/multi_generic_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"tutorials/multi/#Deep-ensemble","page":"Multi-class target","title":"Deep ensemble","text":"","category":"section"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"ùìú = build_ensemble(5;kw=(output_dim=out_dim,));","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"using CounterfactualExplanations: forward\nùìú, anim = forward(ùìú, data, opt, n_epochs=epochs, plot_every=1); # fit the ensemble\ngif(anim, \"www/multi_ensemble_loss.gif\", fps=10);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"# Step 1)\nstruct FittedEnsemble <: Models.FittedModel\n    ùìú::AbstractArray\nend\n\n# Step 2)\nusing Statistics\nlogits(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.stack([nn(X) for nn in ùë¥.ùìú],3), dims=3)\nprobs(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.stack([softmax(nn(X)) for nn in ùë¥.ùìú],3),dims=3)\n\nùë¥=FittedEnsemble(ùìú);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"plt = plot_contour_multi(X',y,ùë¥);\nsavefig(plt, \"www/multi_ensemble_contour.png\")","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"generator = GreedyGenerator(0.25,20,:logitcrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"Deep ensemble\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/multi_greedy_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/multi/","page":"Multi-class target","title":"Multi-class target","text":"(Image: )","category":"page"},{"location":"intro/","page":"-","title":"-","text":"Installation\nBackground and motivation\nUsage example\nGoals and limitations\nCitation","category":"page"},{"location":"intro/","page":"-","title":"-","text":"CounterfactualExplanations.jl is a Julia package for generating Counterfactual Explanations (CE) and Algorithmic Recourse (AR) for black-box algorithms. Both CE and AR are related tools for interpretable machine learning. See below for short introduction and other resources or dive straight into the docs.","category":"page"},{"location":"intro/#Installation","page":"-","title":"Installation","text":"","category":"section"},{"location":"intro/","page":"-","title":"-","text":"The package is in its early stages of development and currently awaiting registry on Julia‚Äôs General Registry. In the meantime it can be installed as follows:","category":"page"},{"location":"intro/","page":"-","title":"-","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/CounterfactualExplanations.jl\")","category":"page"},{"location":"intro/","page":"-","title":"-","text":"To instead install the development version of the package you can run the following command:","category":"page"},{"location":"intro/","page":"-","title":"-","text":"using Pkg\nPkg.add(url=\"https://github.com/pat-alt/CounterfactualExplanations.jl\", rev=\"dev\")","category":"page"},{"location":"intro/#Background-and-motivation","page":"-","title":"Background and motivation","text":"","category":"section"},{"location":"intro/","page":"-","title":"-","text":"Algorithms used for automated decision-making such as deep neural networks have become so complex and opaque over recent years that they are generally considered as black boxes. This creates the following undesirable scenario: the human operators in charge of the black-box decision-making system do not understand how it works and essentially rely on it blindly. Conversely, those individuals who are subject to the decisions produced by such systems typically have no way of challenging them.","category":"page"},{"location":"intro/","page":"-","title":"-","text":"‚ÄúYou cannot appeal to (algorithms). They do not listen. Nor do they bend.‚Äù‚Äî Cathy O‚ÄôNeil in Weapons of Math Destruction, 2016","category":"page"},{"location":"intro/","page":"-","title":"-","text":"Counterfactual Explanations can help programmers make sense of the systems they build: they explain how inputs into a system need to change for it to produce a different output. Figure¬†1, for example, shows various counterfactuals generated through different approaches that all turn the predicted label of some classifier from a 9 into a 4. CEs that involve realistic and actionable changes such as the one on the far right can be used for the purpose of individual recourse.","category":"page"},{"location":"intro/","page":"-","title":"-","text":"<figure> <img src=\"examples/image/www/MNIST_9to4.png\" id=\"fig-mnist\" alt=\"Figure 1: Realistic counterfactual explanations for MNIST data: turning a 4 into a 9.\" /> <figcaption aria-hidden=\"true\">Figure 1: Realistic counterfactual explanations for MNIST data: turning a 4 into a 9.</figcaption> </figure>","category":"page"},{"location":"intro/","page":"-","title":"-","text":"Algorithmic Recourse (AR) offers individuals subject to algorithms a way to turn a negative decision into positive one. Figure¬†2 illustrates the point of AR through a toy example: it shows the counterfactual path of one sad cat üê± that would like to be grouped with her cool dog friends. Unfortunately, based on her tail length and height she was classified as a cat by a black-box classifier. The recourse algorithm perturbs her features in such a way that she ends up crossing the decision boundary into a dense region inside the target class.","category":"page"},{"location":"intro/","page":"-","title":"-","text":"<figure> <img src=\"examples/www/recourse_laplace.gif\" id=\"fig-cat\" alt=\"Figure 2: A sad üê± on its counterfactual path to its cool dog friends.\" /> <figcaption aria-hidden=\"true\">Figure 2: A sad üê± on its counterfactual path to its cool dog friends.</figcaption> </figure>","category":"page"},{"location":"intro/#Usage-example","page":"-","title":"Usage example","text":"","category":"section"},{"location":"intro/#Goals-and-limitations","page":"-","title":"Goals and limitations","text":"","category":"section"},{"location":"intro/","page":"-","title":"-","text":"The goal for this library is to contribute to efforts towards trustworthy machine learning in Julia. The Julia language has an edge when it comes to trustworthiness: it is very transparent. Packages like this one are generally written in 100% Julia, which makes it easy for users and developers to understand and contribute to open source code.","category":"page"},{"location":"intro/","page":"-","title":"-","text":"Eventually the aim for this project is to be at least at par with the amazing CARLA Python library which was presented at NeurIPS 2021. Currently CounterfactualExplanations.jl falls short of this goal in a number of ways: 1) the number of counterfactual generators is limited, 2) it lacks a framework for evaluating and benchmarking different generators, 3) it has so far been a one-person effort and not yet gone through a formal review.","category":"page"},{"location":"intro/#Citation","page":"-","title":"Citation","text":"","category":"section"},{"location":"intro/","page":"-","title":"-","text":"If you want to use this codebase, please cite:","category":"page"},{"location":"intro/","page":"-","title":"-","text":"@software{altmeyer2022CounterfactualExplanations,\n  author = {Patrick Altmeyer},\n  title = {{CounterfactualExplanations.jl - a julia package for Counterfactual Explanations and Algorithmic Recourse}},\n  url = {https://github.com/pat-alt/CounterfactualExplanations.jl},\n  version = {0.1.0},\n  year = {2022}\n}","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"In this examples we will see how different counterfactual generators can be used to explain deep learning models for image classification. In particular, we will look at MNIST data and visually inspect how the different generators perturb images of handwritten digits in order to change the predicted label to a target label. Figure¬†1 shows a random sample of handwritten digits.","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\" execution_count=\"15\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"using CounterfactualExplanations, Plots, MLDatasets\nusing MLDatasets.MNIST: convert2image\nusing BSON: @save, @load","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\" execution_count=\"20\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"train_x, train_y = MNIST.traindata()\ninput_dim = prod(size(train_x[:,:,1]))\nusing Images, Random, StatsBase\nRandom.seed!(1)\nn_samples = 10\nsamples = train_x[:,:,sample(1:end, n_samples, replace=false)]\nmosaic = mosaicview([convert2image(samples[:,:,i]) for i ‚àà 1:n_samples]...,ncol=Int(n_samples/2))\nplt = plot(mosaic, size=(500,260), axis=nothing, background=:transparent)\nsavefig(plt, \"www/mnist_samples.png\")","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<figure> <img src=\"www/mnist_samples.png\" id=\"fig-samples\" alt=\"Figure 1: A few random handwritten digits.\" /> <figcaption aria-hidden=\"true\">Figure 1: A few random handwritten digits.</figcaption> </figure>","category":"page"},{"location":"examples/image/MNIST/#Pre-trained-classifiers","page":"MNIST","title":"Pre-trained classifiers","text":"","category":"section"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"Next we will load two pre-trained deep-learning classifiers:","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"Simple MLP - model\nDeep ensemble - ùìú","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"using Flux\nusing CounterfactualExplanations.Data: mnist_data, mnist_model, mnist_ensemble\nx,y,data = getindex.(Ref(mnist_data()), (\"x\", \"y\", \"data\"))\nmodel = mnist_model()\nùìú = mnist_ensemble();","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"The following code just prepares the models to be used with CounterfactualExplanations.jl:","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\" execution_count=\"18\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"using CounterfactualExplanations, CounterfactualExplanations.Models\nimport CounterfactualExplanations.Models: logits, probs # import functions in order to extend\n\n# MLP:\n# Step 1)\nstruct NeuralNetwork <: Models.FittedModel\n    nn::Any\nend\n# Step 2)\nlogits(ùë¥::NeuralNetwork, X::AbstractArray) = ùë¥.nn(X)\nprobs(ùë¥::NeuralNetwork, X::AbstractArray)= softmax(logits(ùë¥, X))\nùë¥ = NeuralNetwork(model)\n\n# Deep ensemble:\n# Step 1)\nstruct FittedEnsemble <: Models.FittedModel\n    ùìú::AbstractArray\nend\n# Step 2)\nusing Statistics\nlogits(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.stack([nn(X) for nn in ùë¥.ùìú],3), dims=3)\nprobs(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.stack([softmax(nn(X)) for nn in ùë¥.ùìú],3),dims=3)\nùë¥_ensemble=FittedEnsemble(ùìú);","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/#Generating-counterfactuals","page":"MNIST","title":"Generating counterfactuals","text":"","category":"section"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"We will look at four different approaches here:","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"Generic approach for the MLP (Wachter, Mittelstadt, and Russell 2017).\nGreedy approach for the MLP.\nGeneric approach for the deep ensemble.\nGreedy approach for the deep ensemble (Schut et al. 2021).","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"They can be implemented using the GenericGenerator and the GreedyGenerator.","category":"page"},{"location":"examples/image/MNIST/#Turning-a-9-into-a-4","page":"MNIST","title":"Turning a 9 into a 4","text":"","category":"section"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"We will start with an example that should yield intuitive results: the process of turning a handwritten 9 in Figure¬†2 into a 4 is straight-forward for a human - just erase the top part. Let‚Äôs see how the different algorithmic approaches perform.","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\" execution_count=\"21\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"# Randomly selected factual:\nRandom.seed!(1234);\nxÃÖ = Flux.unsqueeze(x[:,rand(1:size(x)[2])],2)\ntarget = 5\nŒ≥ = 0.95\nimg = convert2image(reshape(xÃÖ,Int(sqrt(input_dim)),Int(sqrt(input_dim))))\nplt_orig = plot(img, title=\"Original\", axis=nothing)\nsavefig(plt_orig, \"www/mnist_original.png\")","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<figure> <img src=\"www/mnist_original.png\" id=\"fig-nine\" alt=\"Figure 2: A random handwritten 9.\" /> <figcaption aria-hidden=\"true\">Figure 2: A random handwritten 9.</figcaption> </figure>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"The code below implements the four different approaches one by one. Figure¬†3 shows the resulting counterfactuals. In every case the desired label switch is achieved, that is the corresponding classifier classifies the counterfactual as a four. But arguably from a human perspective only the counterfactuals for the deep ensemble look like a 4. For the MLP, both the generic and the greedy approach generate coutnerfactuals that look much like adversarial examples.","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div class=\"cell\" execution_count=\"134\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"# Generic - MLP\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitcrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥; feasible_range=(0.0,1.0)) # generate recourse\nimg = convert2image(reshape(recourse.xÃ≤,Int(sqrt(input_dim)),Int(sqrt(input_dim))))\nplt_wachter = plot(img, title=\"MLP - Wachter\")\n\n# Greedy - MLP\ngenerator = GreedyGenerator(0.1,15,:logitcrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥; feasible_range=(0.0,1.0)) # generate recourse\nimg = convert2image(reshape(recourse.xÃ≤,Int(sqrt(input_dim)),Int(sqrt(input_dim))))\nplt_greedy = plot(img, title=\"MLP - Greedy\")\n\n# Generic - Deep Ensemble\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitcrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥_ensemble, target, Œ≥; feasible_range=(0.0,1.0)) # generate recourse\nimg = convert2image(reshape(recourse.xÃ≤,Int(sqrt(input_dim)),Int(sqrt(input_dim))))\nplt_wachter_de = plot(img, title=\"Ensemble - Wachter\")\n\n# Greedy - Deep Ensemble\ngenerator = GreedyGenerator(0.1,15,:logitcrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥_ensemble, target, Œ≥; feasible_range=(0.0,1.0)) # generate recourse\nimg = convert2image(reshape(recourse.xÃ≤,Int(sqrt(input_dim)),Int(sqrt(input_dim))))\nplt_greedy_de = plot(img, title=\"Ensemble - Greedy\")\n\nplt_list = [plt_orig, plt_wachter, plt_greedy, plt_wachter_de, plt_greedy_de]\nplt = plot(plt_list...,layout=(1,length(plt_list)),axis=nothing, size=(1200,240))\nsavefig(plt, \"www/MNIST_9to4.png\")","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<figure> <img src=\"www/MNIST_9to4.png\" id=\"fig-example\" alt=\"Figure 3: Counterfactual explanations for MNIST data: turning a 9 into a 4\" /> <figcaption aria-hidden=\"true\">Figure 3: Counterfactual explanations for MNIST data: turning a 9 into a 4</figcaption> </figure>","category":"page"},{"location":"examples/image/MNIST/#References","page":"MNIST","title":"References","text":"","category":"section"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div id=\"refs\" class=\"references csl-bib-body hanging-indent\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div id=\"ref-schut2021generating\" class=\"csl-entry\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"Schut, Lisa, Oscar Key, Rory Mc Grath, Luca Costabello, Bogdan Sacaleanu, Yarin Gal, et al. 2021. ‚ÄúGenerating Interpretable Counterfactual Explanations by Implicit Minimisation of Epistemic and Aleatoric Uncertainties.‚Äù In International Conference on Artificial Intelligence and Statistics, 1756‚Äì64. PMLR.","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"<div id=\"ref-wachter2017counterfactual\" class=\"csl-entry\">","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"Wachter, Sandra, Brent Mittelstadt, and Chris Russell. 2017. ‚ÄúCounterfactual Explanations Without Opening the Black Box: Automated Decisions and the GDPR.‚Äù Harv. JL & Tech. 31: 841.","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"examples/image/MNIST/","page":"MNIST","title":"MNIST","text":"</div>","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/CounterfactualExplanations.jl\")","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"To instead install the development version of the package you can run the following command:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/pat-alt/CounterfactualExplanations.jl\", rev=\"dev\")","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"reference/#All-functions-and-types","page":"Reference","title":"All functions and types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Exported-functions","page":"Reference","title":"Exported functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CounterfactualExplanations, CounterfactualExplanations.Generators, CounterfactualExplanations.Models, CounterfactualExplanations.Losses]\nPrivate = false","category":"page"},{"location":"reference/#CounterfactualExplanations.generate_counterfactual-Tuple{Generator, AbstractArray, CounterfactualExplanations.Models.FittedModel, Union{Float64, Int64}, Float64}","page":"Reference","title":"CounterfactualExplanations.generate_counterfactual","text":"generate_counterfactual(generator::Generator, xÃÖ::Vector, ùë¥::Models.FittedModel, target::Float64, Œ≥::Float64; T=1000)\n\nTakes a recourse generator, the factual sample xÃÖ, the fitted model ùë¥, the target label and its desired threshold probability Œ≥. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generator\n\nusing CounterfactualExplanations.Models\nw = [1.0 -2.0] # true coefficients\nb = [0]\nxÃÖ = [-1,0.5]\ntarget = 1.0\nŒ≥ = 0.9\nùë¥ = LogisticModel(w, b)\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse\n\nGreedy generator (Bayesian model only)\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nŒº = [0 1.0 -2.0] # MAP coefficients\nŒ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nxÃÖ = [-1,0.5]\ntarget = 1.0\nŒ≥ = 0.9\nùë¥ = CounterfactualExplanations.Models.BayesianLogisticModel(Œº, Œ£);\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse\n\nSee also:\n\nGenericGenerator(Œª::Float64, œµ::Float64, œÑ::Float64, loss::Symbol, ùë≠::Union{Nothing,Vector{Symbol}})\nGreedyGenerator(Œ¥::Float64, n::Int64, loss::Symbol, ùë≠::Union{Nothing,Vector{Symbol}}).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Generators.Generator","page":"Reference","title":"CounterfactualExplanations.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.Generators.GenericGenerator","page":"Reference","title":"CounterfactualExplanations.Generators.GenericGenerator","text":"GenericGenerator(Œª::Float64, œµ::Float64, œÑ::Float64, loss::Symbol, ùë≠::Union{Nothing,Vector{Symbol}})\n\nA constructor for a generic recourse generator. It takes values for the complexity penalty Œª, the learning rate œµ, the tolerance for convergence œÑ,      the type of loss function to be used in the recourse objective and a mutability constraint mask ùë≠.\n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\n\nSee also:\n\ngenerate_counterfactual(generator::Generator, xÃÖ::Vector, ùë¥::Models.FittedModel, target::Float64; T=1000)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.Generators.GreedyGenerator","page":"Reference","title":"CounterfactualExplanations.Generators.GreedyGenerator","text":"GreedyGenerator(Œ¥::Float64, n::Int64, loss::Symbol, ùë≠::Union{Nothing,Vector{Symbol}})\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the perturbation size Œ¥, the maximum number of times n that any feature can be changed,      the type of loss function to be used in the recourse objective and a mutability constraint mask ùë≠.\n\nExamples\n\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy, nothing)\n\nSee also:\n\ngenerate_counterfactual(generator::Generator, xÃÖ::Vector, ùë¥::Models.FittedModel, target::Float64; T=1000)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.Models.BayesianLogisticModel","page":"Reference","title":"CounterfactualExplanations.Models.BayesianLogisticModel","text":"BayesianLogisticModel(Œº::Matrix,Œ£::Matrix)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates Œº (coefficients including constant term(s)) and Œ£ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nŒº = [0 1.0 -2.0] # MAP coefficients\nŒ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nùë¥ = CounterfactualExplanations.Models.BayesianLogisticModel(Œº, Œ£);\n\nSee also:\n\nlogits(ùë¥::BayesianLogisticModel, X::AbstractArray)\nprobs(ùë¥::BayesianLogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.Models.LogisticModel","page":"Reference","title":"CounterfactualExplanations.Models.LogisticModel","text":"LogisticModel(W::Matrix,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0 -2.0] # estimated coefficients\nb = [0] # estimated constant\nùë¥ = CounterfactualExplanations.Models.LogisticModel(w, b);\n\nSee also: \n\nlogits(ùë¥::LogisticModel, X::AbstractArray)\nprobs(ùë¥::LogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.Models.logits-Tuple{CounterfactualExplanations.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"CounterfactualExplanations.Models.logits","text":"logits(ùë¥::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as Œº[1·µÄ X·µÄ]·µÄ.\n\nExamples\n\nusing CounterfactualExplanations.Models\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nŒº = [0 1.0 -2.0] # MAP coefficients\nŒ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nùë¥ = BayesianLogisticModel(Œº, Œ£);\nx = [1,1]\nlogits(ùë¥, x)\n\nSee also BayesianLogisticModel(Œº::Matrix,Œ£::Matrix)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Models.logits-Tuple{CounterfactualExplanations.Models.LogisticModel, AbstractArray}","page":"Reference","title":"CounterfactualExplanations.Models.logits","text":"logits(ùë¥::LogisticModel, X::AbstractArray)\n\nComputes logits as WX+b.\n\nExamples\n\nusing CounterfactualExplanations.Models\nw = [1.0 -2.0] # estimated coefficients\nb = [0] # estimated constant\nùë¥ = LogisticModel(w, b);\nx = [1,1]\nlogits(ùë¥, x)\n\nSee also LogisticModel(W::Matrix,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Models.probs-Tuple{CounterfactualExplanations.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"CounterfactualExplanations.Models.probs","text":"probs(ùë¥::BayesianLogisticModel, X::AbstractArray)\n\nComputes predictive probabilities using a Probit approximation. \n\nExamples\n\nusing CounterfactualExplanations.Models\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nŒº = [0 1.0 -2.0] # MAP coefficients\nŒ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nùë¥ = BayesianLogisticModel(Œº, Œ£);\nx = [1,1]\nprobs(ùë¥, x)\n\nSee also BayesianLogisticModel(Œº::Matrix,Œ£::Matrix)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Models.probs-Tuple{CounterfactualExplanations.Models.LogisticModel, AbstractArray}","page":"Reference","title":"CounterfactualExplanations.Models.probs","text":"probs(ùë¥::LogisticModel, X::AbstractArray)\n\nComputes predictive probabilities from logits as œÉ(WX+b) where 'œÉ' is the sigmoid function. \n\nExamples\n\nusing CounterfactualExplanations.Models\nw = [1.0 -2.0] # estimated coefficients\nb = [0] # estimated constant\nùë¥ = LogisticModel(w, b);\nx = [1,1]\nprobs(ùë¥, x)\n\nSee also LogisticModel(W::Matrix,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Losses.hinge_loss-Tuple{Any, Any}","page":"Reference","title":"CounterfactualExplanations.Losses.hinge_loss","text":"hinge_loss(yÃÇ, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Internal-functions","page":"Reference","title":"Internal functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [CounterfactualExplanations, CounterfactualExplanations.Generators, CounterfactualExplanations.Models, CounterfactualExplanations.Losses]\nPublic = false","category":"page"},{"location":"reference/#CounterfactualExplanations.Recourse","page":"Reference","title":"CounterfactualExplanations.Recourse","text":"Recourse(xÃ≤::AbstractArray, yÃ≤::Float64, path::Matrix{Float64}, generator::Generators.Generator, xÃÖ::AbstractArray, yÃÖ::Float64, ùë¥::Models.FittedModel, target::Float64)\n\nCollects all variables relevant to the recourse outcome. \n\n\n\n\n\n","category":"type"},{"location":"reference/#CounterfactualExplanations.apply_mutability-Tuple{AbstractArray, Vector{Symbol}}","page":"Reference","title":"CounterfactualExplanations.apply_mutability","text":"apply_mutability(ŒîxÃ≤::AbstractArray, ùë≠::Vector{Symbol})\n\nApply mutability constraints to ŒîxÃ≤ based on vector of constraints ùë≠.\n\nExamples\n\nùë≠ = [:both, :increase, :decrease, :none] applymutability([-1,1,-1,1], ùë≠) # all but :none pass applymutability([-1,-1,-1,1], ùë≠) # all but :increase and :none pass applymutability([-1,1,1,1], ùë≠) # all but :decrease and :none pass applymutability([-1,-1,1,1], ùë≠) # only :both passes\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.target_probs-Tuple{AbstractArray, Union{Int64, AbstractFloat}}","page":"Reference","title":"CounterfactualExplanations.target_probs","text":"target_probs(p, target)\n\nSelects the probabilities of the target class. In case of binary classification problem p reflects the probability that y=1. In that case 1-p reflects the probability that y=0.\n\nExamples\n\nusing CounterfactualExplanations\nusing CounterfactualExplanations.Models: LogisticModel, probs \nRandom.seed!(1234)\nN = 25\nw = [1.0 1.0]# true coefficients\nb = 0\nx, y = toy_data_linear(N)\n# Logit model:\nùë¥ = LogisticModel(w, [b])\np = probs(ùë¥, x[rand(N)])\ntarget_probs(p, 0)\ntarget_probs(p, 1)\n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.threshold_reached-Tuple{CounterfactualExplanations.Models.FittedModel, AbstractArray, Real, Real}","page":"Reference","title":"CounterfactualExplanations.threshold_reached","text":"threshold_reached(ùë¥::Models.FittedModel, xÃ≤::AbstractArray, target::Float64, Œ≥::Float64)\n\nChecks if confidence threshold has been reached. \n\n\n\n\n\n","category":"method"},{"location":"reference/#CounterfactualExplanations.Models.FittedModel","page":"Reference","title":"CounterfactualExplanations.Models.FittedModel","text":"FittedModel\n\nBase type for fitted models.\n\n\n\n\n\n","category":"type"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"tutorials/loss/#Loss-functions-and-gradients","page":"Loss functions","title":"Loss functions and gradients","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"This is a short tutorial on loss functions and gradients typically involved in counterfactual search. It involves more maths than perhaps some of the other tutorials.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"using Zygote, Plots, PlotThemes, LinearAlgebra\ntheme(:wong)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"LogLevel(1)","category":"page"},{"location":"tutorials/loss/#General-setup","page":"Loss functions","title":"General setup","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"We begin by restating the general setup for generic counterfactual search. Let tin01 denote the target label, M the model (classifier) and underlinexinmathbbR^D the vector of counterfactual features (we will assume all features are continuous). Then the differentiable optimization problem in algorithmic recourse is generally of the following form","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"underlinex = arg min_underlinex  ell(M(underlinex)t) + lambda h(underlinex)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"where ell denotes some loss function targeting the deviation between the target label and the predicted label and h(cdot) acts as a complexity penality generally addressing the realism or cost of the proposed counterfactual. ","category":"page"},{"location":"tutorials/loss/#Loss-function-\\ell","page":"Loss functions","title":"Loss function ell","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Different choices for ell come to mind, each potentially leading to very different counterfactual outcomes. In practice, ell is often implemented with respect to the logits a=mathbfw^Tx rather than the probabilities p(underliney=1underlinex)=sigma(a) predicted by the classifier. We follow this convention here, but as we shall see depeding on the label domain this convention does not work well for every type of loss function. Common choices for ell in the literature include margin-based loss function like Hinge loss and logit binary crossentropy (or log) loss. Some use distance-based loss such as mean squared error loss (MSE).","category":"page"},{"location":"tutorials/loss/#Hinge-loss","page":"Loss functions","title":"Hinge loss","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"With respect to the logits a=mathbfwx Hinge loss can be defined as follows","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"ell(at^*)=(1-acdot t^*)_+=max01-acdot t^*","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"where t^* is the target label in -11. Since above we defined tin01 we need a mapping h 01 mapsto -11. Specifically, we want to plug in h(t)=t^* where h(cdot) is just the following conditional:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\nh(t)=begincases\n-1  textif  t=0  1  textif  t=1\nendcases\nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Then our loss function as function of t can restated as follows:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"ell(at^*)=ell(at)=(1-acdot h(t))_+=max01-acdot h(t)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The first-order derivative of Hinge loss with respect to the logits a is simply","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\nell(at)=begincases\n-h(t)  textif  a cdot h(t)=1  0  textotherwise \nendcases\nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"In the context of counterfactual search the gradient with respect to the feature vector is then:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n nabla_underlinex ell(at)= begincases\n-h(t)mathbfw  textif  h(t)mathbfw^Tunderlinex=1  0  textotherwise \nendcases\nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"In practice gradients are commonly computed through autodifferentiation. In this tutorial we use the Zygote.jl package which is at the core of Flux.jl, the main deep learning library for Julia.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The side-by-side plot below visualises the loss function and its derivative. The plot further below serves as a simple sanity check to verify that autodifferentiation indeed yields the same result as the closed-form solution for the gradient.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"h(t) = ifelse(t==1,1,-1)\nhinge(a,t) = max(0,1-a*h(t))","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"hinge (generic function with 1 method)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"default(size=(500,500))\na = -2:0.05:2\np1 = plot(a, [hinge(a,1) for a=a], title=\"Loss, t=1\", xlab=\"logits\")\np2 = plot(a, [gradient(hinge,a,1)[1] for a=a], title=\"Gradient, t=1\", xlab=\"logits\")\np3 = plot(a, [hinge(a,0) for a=a], title=\"Loss, t=0\", xlab=\"logits\")\np4 = plot(a, [gradient(hinge,a,0)[1] for a=a], title=\"Gradient, t=0\", xlab=\"logits\")\nplot(p1, p2, p3, p4, layout = (2, 2), legend = false)\nsavefig(\"www/loss_grad_hinge.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Just verifying that the formula for the gradient above indeed yields the same result.\nfunction gradient_man(x,w,t)\n    ùê† = ifelse(h(t)*w'x<=1, -h(t)*w, 0)\n    return ùê†\nend;\nplot(a, [gradient_man(a,1,1) for a=a], legend=:bottomright, label=\"Manual\", title=\"Gradient\", xlab=\"logits\")\nscatter!(a, [gradient(hinge,a,1)[1] for a=a], label=\"Autodiff\")\nsavefig(\"www/loss_grad_hinge_test.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/#Logit-binary-crossentropy-loss","page":"Loss functions","title":"Logit binary crossentropy loss","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Logit binary crossentropy loss loss (sometimes referred to as log loss) is defined as follows:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n ell(at)=- left( t cdot log(sigma(a)) + (1-t) cdot log (1-sigma(a)) right) \nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"where sigma(a) is the logit/sigmoid link function.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Once again for the purpose of counter factual search we are interested in the first-order derivative with respect to our feature vector underlinex. You can verify that the partial derivative with respect to feature underlinex_d is as follows:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n fracpartial ell(at)partial underlinex_d= (sigma(a) - t) w_d \nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The gradient just corresponds to the stacked vector of partial derivatives:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n nabla_underlinex ell(at)= (sigma(a) - t) mathbfw \nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"As before implementation below is done through autodifferentiation. As before the side-by-side plot shows the resulting loss function and its gradient and the plot further below is a simple sanity check.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# sigmoid function:\nfunction ùõî(a)\n    trunc = 8.0 # truncation to avoid numerical over/underflow\n    a = clamp.(a,-trunc,trunc)\n    p = exp.(a)\n    p = p ./ (1 .+ p)\n    return p\nend\n\n# Logit binary crossentropy:\nlogitbinarycrossentropy(a, t) = - (t * log(ùõî(a)) + (1-t) * log(1-ùõî(a)))","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"logitbinarycrossentropy (generic function with 1 method)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"p1 = plot(a, [logitbinarycrossentropy(a,1) for a=a], title=\"Loss, t=1\", xlab=\"logits\")\np2 = plot(a, [gradient(logitbinarycrossentropy,a,1)[1] for a=a], title=\"Gradient, t=1\", xlab=\"logits\")\np3 = plot(a, [logitbinarycrossentropy(a,0) for a=a], title=\"Loss, t=0\", xlab=\"logits\")\np4 = plot(a, [gradient(logitbinarycrossentropy,a,0)[1] for a=a], title=\"Gradient, t=0\", xlab=\"logits\")\nplot(p1, p2, p3, p4, layout = (2, 2), legend = false)\nsavefig(\"www/loss_grad_log.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Just verifying that the formula for the gradient above indeed yields the same result.\nfunction gradient_man(x,w,y)\n    ùê† = (ùõî(w'x) - y) .* w\n    return ùê†\nend;\nplot(a, [gradient_man(a,1,1) for a=a], legend=:bottomright, label=\"Manual\", title=\"Gradient\", xlab=\"logits\")\nscatter!(a, [gradient(logitbinarycrossentropy,a,1)[1] for a=a], label=\"Autodiff\")\nsavefig(\"www/loss_grad_log_test.png\")","category":"page"},{"location":"tutorials/loss/#Mean-squared-error","page":"Loss functions","title":"Mean squared error","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Some authors work with distance-based loss functions instead. Since in general we are interested in providing valid recourse, that is counterfactual explanations that indeed lead to the desired label switch, using one of the margin-based loss functions introduced above seems like a more natural choice. Nonetheless, we shall briefly introduce one of the common distance-based loss functions as well. ","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The mean squared error for counterfactual search implemented with respect to the logits is simply the squared ell^2 norm between the target label and a=mathbfw^Tx:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n ell(at)= t-a^2\nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The gradient with respect to the vector of features is then:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"beginaligned\n nabla_underlinex ell(at)= 2(a - t) mathbfw \nendaligned","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"As before implementation and visualizations follow below.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"mse(a,t) = norm(t - a)^2","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"mse (generic function with 1 method)","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"NOTE: I hinted above that the convention of taking derivatives with respect to logits can go wrong depending on the loss function we choose. The plot below demonstrates this point: for t=0 the global minimum of the MSE is of course also at 0. The implication for counterfactual search is that for t=0 the search stops when mathbfw^Tunderlinex=0. But at this point sigma(mathbfw^Tunderlinex)=05, in other words we stop right at the decision boundary, but never cross it. We will see an example of this below. Key takeaway: carefully think about the choice of your loss function and DON'T us distance-based loss functions when optimizing with respect to logits.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"p1 = plot(a, [mse(a,1) for a=a], title=\"Loss, t=1\", xlab=\"logits\")\np2 = plot(a, [gradient(mse,a,1)[1] for a=a], title=\"Gradient, t=1\", xlab=\"logits\")\np3 = plot(a, [mse(a,0) for a=a], title=\"Loss, t=0\", xlab=\"logits\")\np4 = plot(a, [gradient(mse,a,0)[1] for a=a], title=\"Gradient, t=0\", xlab=\"logits\")\nplot(p1, p2, p3, p4, layout = (2, 2), legend = false)\nsavefig(\"www/loss_grad_mse.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Just verifying that the formula for the gradient above indeed yields the same result.\nfunction gradient_man(x,w,y)\n    ùê† = 2*(w'x - y) .* w\n    return ùê†\nend;\nplot(a, [gradient_man(a,1,1) for a=a], legend=:bottomright, label=\"Manual\", title=\"Gradient\", xlab=\"logits\")\nscatter!(a, [gradient(mse,a,1)[1] for a=a], label=\"Autodiff\")\nsavefig(\"www/loss_grad_mse_test.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/#Example-in-2D","page":"Loss functions","title":"Example in 2D","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"To understand the properties of the different loss functions we will now look at a toy example in 2D. The code below generates some random features and assigns labels based on a fixed vector of coefficients using the sigmoid function.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Some random data:\nusing Flux\nusing Random\nRandom.seed!(1234);\nN = 25\nw = [1.0 -2.0]# true coefficients\nb = 0\nX = reshape(randn(2*N),2,N).*1 # random features\ny = Int.(round.(Flux.œÉ.(w*X .+ b))); # label based on sigmoid","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The plot below shows the samples coloured by label along with the decision boundary. You can think of this as representing the outcome of some automated decision making system. The highlighted sample was chosen to receive algorithmic recourse in the following: we will search for a counterfactual that leads to a label switch.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Plot with random sample chose for recourse\nfunction plot_data(;clegend=true,title=\"\",size=1.2.*(400,300))\n    x_range = collect(range(minimum(X[1,:]),stop=maximum(X[1,:]),length=50))\n    y_range = collect(range(minimum(X[2,:]),stop=maximum(X[2,:]),length=50))\n    Z = [Flux.œÉ.(w * [x,y] .+ b)[1] for x=x_range, y=y_range]\n    plt = contourf(\n        x_range, y_range, Z', legend=clegend, title=title, size=size, lw=0.1\n    )\n    scatter!(plt, X[1,reshape(y.==1,25)],X[2,reshape(y.==1,25)],label=\"y=1\",color=1) # features\n    scatter!(plt, X[1,reshape(y.==0,25)],X[2,reshape(y.==0,25)],label=\"y=0\",color=0) # features\n    Plots.abline!(plt,0.5,b,color=\"black\",label=\"\",lw=2) # decision boundary\n    return plt\nend\n\nplt = plot_data()\nxÃÖ = X[:,5]\nyÃÖ = round.(Flux.œÉ.(w*xÃÖ .+ b))[1]\nscatter!(plt,[xÃÖ[1]],[xÃÖ[2]],color=Int.(yÃÖ),markersize=10,label=\"\")\nsavefig(plt, \"www/loss_examlpe.png\")","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Next we will generating recourse using the CounterfactualExplanations.jl package. First we intantiate our model and based on the assigned label we identify the target (the opposite label).","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"using CounterfactualExplanations\nusing CounterfactualExplanations.Models: LogisticModel\nùë¥ = LogisticModel(w, [b]);\ntarget = ifelse(yÃÖ==1.0,0.0,1.0)\nŒ≥ = 0.75","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"0.75","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Now we instantiate different generators for our different loss functions and different choices of lambda. Finally we generate recourse for each of them:","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Generating recourse\nŒõ = [0, 1, 5] # varying complexity penalties\nlosses = [:hinge_loss, :logitbinarycrossentropy, :mse]\nrecourses = []\nfor loss in losses\n    for Œª in Œõ\n        gen = GenericGenerator(Œª,0.1,1e-5,loss,nothing) \n        rec = generate_counterfactual(gen, xÃÖ, ùë¥, target, Œ≥, T=25)\n        recourses = vcat(recourses, (rec=rec, Œª=Œª, loss=loss))\n    end\nend","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"The code below plots the resulting counterfactual paths. ","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Complexity penalty lambda: has the expected effect of penalizing long counterfactual paths: as the distance between overlinex and underlinex the penalty exerts more and more pressure on the gradient in the opposite direction nablaell. For large choices of lambda valid recourse is not attainable.\nConfidence threshold gamma: note how for both log loss and hinge loss we overshoot a bit, that is we end up well beyond the decision boundary. This is because above we chose a confidence threshold of gamma=075. In the context of recourse this choice matters a lot: we have a longer distance to travel (=higher costs for the individual), but we can be more confident that recourse will remain valid. There is of course an interplay between lambda and gamma.\nThe choice of the loss function matters: the distance-based MSE does NOT work without further ajustments when optimizing with respect to logits, as discussed above. ","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"Overall, in the context of this toy example log loss arguably generates the most reasonable outcome: firstly, we can observe that the step size decreases at an increasing rate as the search approaches convergence (which may be desirable); secondly, it appears that increasing lambda leads to a roughly proportional decrease in the distance of the final counterfactual. This stands in contrast to the outcome for Hinge loss, where increasing lambda from 0 to 1 barely has any effect at all.","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"# Plotting\nk = length(recourses)\nfunction plot_recourse(rec, idx)\n    plt = plot_data(clegend=false, size=(floor(sqrt(k)) * 350, ceil(sqrt(k)) * 350))\n    idx_path = minimum([idx, size(rec.rec.path)[1]])\n    scatter!(plt, rec.rec.path[1:idx_path,1], rec.rec.path[1:idx_path,2], color=Int(yÃÖ))\n    scatter!(plt, [rec.rec.path[idx_path,1]],[rec.rec.path[idx_path,2]],color=Int(yÃÖ),markersize=10)\nend\nmax_path_length = maximum(map(rec -> size(rec.rec.path)[1], recourses))\nanim = @animate for i in 1:max_path_length\n    plots = map(rec -> plot_recourse(rec, i), recourses);\n    plot(plots..., layout = (Int(floor(sqrt(k))), Int(ceil(sqrt(k)))), legend = false, plot_title=\"Iteration: \" * string(i))\nend\ngif(anim, \"www/loss_paths.gif\", fps=5);","category":"page"},{"location":"tutorials/loss/","page":"Loss functions","title":"Loss functions","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = CounterfactualExplanations","category":"page"},{"location":"#CounterfactualExplanations","page":"Home","title":"CounterfactualExplanations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for CounterfactualExplanations.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CounterfactualExplanations.jl is a Julia package for generating Counterfactual Explanations (CE) and Algorithmic Recourse (AR) for black-box algorithms. Both CE and AR are related tools for interpretable machine learning. See below for short introduction and other resources or dive straight into the docs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is in its early stages of development and currently awaiting registry on Julia‚Äôs General Registry. In the meantime it can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/CounterfactualExplanations.jl\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To instead install the development version of the package you can run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(url=\"https://github.com/pat-alt/CounterfactualExplanations.jl\", rev=\"dev\")","category":"page"},{"location":"#Background-and-motivation","page":"Home","title":"Background and motivation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Algorithms used for automated decision-making such as deep neural networks have become so complex and opaque over recent years that they are generally considered as black boxes. This creates the following undesirable scenario: the human operators in charge of the black-box decision-making system do not understand how it works and essentially rely on it blindly. Conversely, those individuals who are subject to the decisions produced by such systems typically have no way of challenging them.","category":"page"},{"location":"","page":"Home","title":"Home","text":"‚ÄúYou cannot appeal to (algorithms). They do not listen. Nor do they bend.‚Äù‚Äî Cathy O‚ÄôNeil in Weapons of Math Destruction, 2016","category":"page"},{"location":"","page":"Home","title":"Home","text":"Counterfactual Explanations can help programmers make sense of the systems they build: they explain how inputs into a system need to change for it to produce a different output. Figure¬†1, for example, shows various counterfactuals generated through different approaches that all turn the predicted label of some classifier from a 9 into a 4. CEs that involve realistic and actionable changes such as the one on the far right can be used for the purpose of individual recourse.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure> <img src=\"https://raw.githubusercontent.com/pat-alt/CounterfactualExplanations.jl/main/docs/src/examples/image/www/MNIST_9to4.png\" id=\"fig-mnist\" alt=\"Figure 1: Realistic counterfactual explanations for MNIST data: turning a 4 into a 9.\" /> <figcaption aria-hidden=\"true\">Figure 1: Realistic counterfactual explanations for MNIST data: turning a 4 into a 9.</figcaption> </figure>","category":"page"},{"location":"","page":"Home","title":"Home","text":"Algorithmic Recourse (AR) offers individuals subject to algorithms a way to turn a negative decision into positive one. Figure¬†2 illustrates the point of AR through a toy example: it shows the counterfactual path of one sad cat üê± that would like to be grouped with her cool dog friends. Unfortunately, based on her tail length and height she was classified as a cat by a black-box classifier. The recourse algorithm perturbs her features in such a way that she ends up crossing the decision boundary into a dense region inside the target class.","category":"page"},{"location":"","page":"Home","title":"Home","text":"<figure> <img src=\"https://raw.githubusercontent.com/pat-alt/CounterfactualExplanations.jl/main/docs/src/examples/www/recourse_laplace.gif\" id=\"fig-cat\" alt=\"Figure 2: A sad üê± on its counterfactual path to its cool dog friends.\" /> <figcaption aria-hidden=\"true\">Figure 2: A sad üê± on its counterfactual path to its cool dog friends.</figcaption> </figure>","category":"page"},{"location":"#Usage-example","page":"Home","title":"Usage example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Generating counterfactuals will typically look like follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using CounterfactualExplanations\nusing CounterfactualExplanations.Models\nw = [1.0 -2.0] # true coefficients\nb = [0]\nùë¥ = LogisticModel(w, b)\nxÃÖ = [-1,0.5]\ntarget = 1.0\nŒ≥ = 0.9\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"","page":"Home","title":"Home","text":"We can see that the counterfactual label yÃ≤ corresponds to the target:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> recourse.yÃ≤\n1.0\n\njulia> recourse.xÃÖ\n2-element Vector{Float64}:\n -1.0\n  0.5\n\njulia> recourse.yÃÖ\n0.0\n\njulia> recourse.xÃ≤\n2-element Vector{Float64}:\n -0.15867040347424893\n -1.182659193051502\n\njulia> recourse.yÃ≤\n1.0","category":"page"},{"location":"#Goals-and-limitations","page":"Home","title":"Goals and limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The goal for this library is to contribute to efforts towards trustworthy machine learning in Julia. The Julia language has an edge when it comes to trustworthiness: it is very transparent. Packages like this one are generally written in 100% Julia, which makes it easy for users and developers to understand and contribute to open source code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Eventually the aim for this project is to be at least at par with the amazing CARLA Python library which was presented at NeurIPS 2021. Currently CounterfactualExplanations.jl falls short of this goal in a number of ways: 1) the number of counterfactual generators is limited, 2) it lacks a framework for evaluating and benchmarking different generators, 3) it has so far been a one-person effort and not yet gone through a formal review.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you want to use this codebase, please cite:","category":"page"},{"location":"","page":"Home","title":"Home","text":"@software{altmeyer2022CounterfactualExplanations,\n  author = {Patrick Altmeyer},\n  title = {{CounterfactualExplanations.jl - a Julia package for Counterfactual Explanations and Algorithmic Recourse}},\n  url = {https://github.com/pat-alt/CounterfactualExplanations.jl},\n  version = {0.1.0},\n  year = {2022}\n}","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"tutorials/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"tutorials/models/#Default-models","page":"Models","title":"Default models","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"There are currently structures for two default models that can be used with CounterfactualExplanations.jl:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\nBayesianLogisticModel(Œº::AbstractArray,Œ£::AbstractArray)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Both take sets of estimated parameters at the point of instantiation: the constructors will not fit a model for you, but assume that you have already estimated the respective model yourself and have access to its parameter estimates. Based on the supplied parameters methods to predict logits and probabilities are already implemented and used in the counterfactual search. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"For the simple logistic regression model logits are computed as a=Xw + b and probabilities are simply sigma(a). For the Bayesian logistic regression model logits are computed as Xmu and the predictive posterior is computed through Laplace approximation.","category":"page"},{"location":"tutorials/models/#Custom-models","page":"Models","title":"Custom models","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Apart from the default models you can use any arbitrary (differentiable) model and generate recourse in the same way as before. Only two steps are necessary to make your own model compatible with CounterfactualExplanations.jl:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The model needs to be declared as a subtype of CounterfactualExplanations.Models.FittedModel.\nYou need to extend the functions CounterfactualExplanations.Models.logits and CounterfactualExplanations.Models.probs to accept your custom model.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Below we will go through a simple example to see how this can be done in practice. ","category":"page"},{"location":"tutorials/models/#Neural-network","page":"Models","title":"Neural network","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"In this example we will build a simple artificial neural network using Flux.jl for a binary classification task.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Import libraries.\nusing Flux, Plots, Random, PlotThemes, Statistics, CounterfactualExplanations\ntheme(:wong)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"LogLevel(1)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"First we generate some toy data below. The code that generates this data was borrowed from a great tutorial about Bayesian neural networks provided by Turing.jl, which you may find here. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The plot below shows the generated samples in the 2D feature space where colours indicate the associated labels. CounterfactualExplanationsly this data is not linearly separable and the default LogisticModel would be ill suited for this classification task.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Number of points to generate.\nN = 80\nM = round(Int, N / 4)\nRandom.seed!(1234)\n\nx, y = toy_data_non_linear(N)\nX = hcat(x...)\nplt = plot()\nplt = plot_data!(plt,X',y);\nsavefig(plt, \"www/models_samples.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/#Training-the-model","page":"Models","title":"Training the model","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Instead we will build a simple artificial neural network nn with one hidden layer. For additional resources on how to do deep learning with Flux.jl just have a look at their documentation. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"nn = build_model(dropout=true,activation=Flux.œÉ)\nloss(x, y) = Flux.Losses.logitbinarycrossentropy(nn(x), y)\nps = Flux.params(nn)\ndata = zip(x,y);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The code below trains the neural network for the task at hand. The plot shows the (training) loss over time. Note that normally we would be interested in loss with respect to a validation data set. But since we are primarily interested in generated recourse for a trained classifier, here we will just keep things very simple.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Flux.Optimise: update!, ADAM\nopt = ADAM()\nepochs = 100\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\nshow_every = epochs/10\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, params(nn), gs)\n  end\n  if epoch % show_every == 0\n    println(\"Epoch \" * string(epoch))\n    @show avg_loss(data)\n  end\nend","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Epoch 10\navg_loss(data) = 0.6892187490309944\nEpoch 20\navg_loss(data) = 0.6767634057872471\nEpoch 30\navg_loss(data) = 0.6557134557550864\nEpoch 40\navg_loss(data) = 0.6238793502186495\nEpoch 50\navg_loss(data) = 0.574156178094375\nEpoch 60\navg_loss(data) = 0.5067736276756599\nEpoch 70\navg_loss(data) = 0.42957685824823677\nEpoch 80\navg_loss(data) = 0.3534671179124217\nEpoch 90\navg_loss(data) = 0.2879001871677585\nEpoch 100\navg_loss(data) = 0.23253485574062113","category":"page"},{"location":"tutorials/models/#Generating-recourse","page":"Models","title":"Generating recourse","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now it's game time: we have a fitted model M mathcalX mapsto y and are interested in generating recourse for some individual overlinexinmathcalX. As mentioned above we need to do a bit more work to prepare the model to be used by CounterfactualExplanations.jl. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The code below takes care of all of that: in step 1) it declares our model as a subtype of Models.FittedModel and in step 2) it just extends the two functions. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using CounterfactualExplanations, CounterfactualExplanations.Models\nimport CounterfactualExplanations.Models: logits, probs # import functions in order to extend\n\n# Step 1)\nstruct NeuralNetwork <: Models.FittedModel\n    nn::Any\nend\n\n# Step 2)\nlogits(ùë¥::NeuralNetwork, X::AbstractArray) = ùë¥.nn(X)\nprobs(ùë¥::NeuralNetwork, X::AbstractArray)= œÉ.(logits(ùë¥, X))\nùë¥ = NeuralNetwork(nn)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"NeuralNetwork(Chain(Dense(2, 32, œÉ), Dropout(0.1), Dense(32, 1)))","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The plot below shows the predicted probabilities in the feature domain. Evidently our simple neural network is doing very well on the training data, as expected. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Plot the posterior distribution with a contour plot.\nplt = plot_contour(X',y,ùë¥);\nsavefig(plt, \"www/models_contour.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now we just select a random sample from our data and based on its current label we set as our target the opposite label and desired threshold for the predicted probability.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Random\nRandom.seed!(123)\nxÃÖ = X[:,rand(1:size(X)[2])]\nyÃÖ = round(probs(ùë¥, xÃÖ)[1])\ntarget = ifelse(yÃÖ==1.0,0.0,1.0) # opposite label as target\nŒ≥ = 0.75; # desired level of confidence","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Then finally we use the GenericGenerator to generate recourse. The plot further below shows the resulting counterfactual path.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"generator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"MLP\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/models_generic_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"HI","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/#Ensemble-of-neural-networks","page":"Models","title":"Ensemble of neural networks","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"In the context of Bayesian classifiers the GreedyGenerator can be used since minimizing the predictive uncertainty acts as a proxy for realism and unambiquity. In other words, if we have a model that incorporates uncertainty, we can generate realistic counterfactuals without the need for a complexity penalty. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"One efficient way to produce uncertainty estimates in the context of deep learning is to simply use an ensemble of artificial neural networks (also referred to as deep ensemble). To this end we can use the build_model function from above repeatedly to compose an ensemble of K neural networks:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"ùìú = build_ensemble(5;kw=(dropout=true,activation=Flux.œÉ));","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now we need to be able to train this ensemble, which boils down to training each neural network separately. For this purpose will just summarize the process for training a single neural network (as per above) in a wrapper function:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"function forward_nn(nn, loss, data, opt; n_epochs=200, plotting=nothing)\n\n    avg_l = []\n    \n    for epoch = 1:n_epochs\n      for d in data\n        gs = gradient(params(nn)) do\n          l = loss(d...)\n        end\n        update!(opt, params(nn), gs)\n      end\n      if !isnothing(plotting)\n        plt = plotting[1]\n        anim = plotting[2]\n        idx = plotting[3]\n        avg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\n        avg_l = vcat(avg_l,avg_loss(data))\n        if epoch % plotting[4]==0\n          plot!(plt, avg_l, color=idx)\n          frame(anim, plt)\n        end\n      end\n    end\n    \nend","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"forward_nn (generic function with 1 method)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"This wrapper function is used as a subroutine in forward below, which returns are an ensemble of fitted neural networks. The animation below shows the training loss for each of them. As we can see the different networks produce different outcomes: their parameters were initialized at different random values. This is how we introduce stochasticity and hence incorporate uncertainty around our estimates.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Statistics\n\nfunction forward(ùìú, data, opt; loss_type=:logitbinarycrossentropy, plot_loss=true, n_epochs=200, plot_every=20) \n\n    anim = nothing\n    if plot_loss\n        anim = Animation()\n        plt = plot(ylim=(0,1), xlim=(0,n_epochs), legend=false, xlab=\"Epoch\", title=\"Average (training) loss\")\n        for i in 1:length(ùìú)\n            nn = ùìú[i]\n            loss(x, y) = getfield(Flux.Losses,loss_type)(nn(x), y)\n            forward_nn(nn, loss, data, opt, n_epochs=n_epochs, plotting=(plt, anim, i, plot_every))\n        end\n    else\n        plt = nothing\n        for nn in ùìú\n            loss(x, y) = getfield(Flux.Losses,loss_type)(nn(x), y)\n            forward_nn(nn, loss, data, opt, n_epochs=n_epochs, plotting=plt)\n        end\n    end\n\n    return ùìú, anim\nend;","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"ùìú, anim = forward(ùìú, data, opt, n_epochs=epochs, plot_every=show_every); # fit the ensemble\ngif(anim, \"www/models_ensemble_loss.gif\", fps=10);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Once again it is straight-forward to make the model compatible with the package. Note that for an ensemble model the predicted logits and probabilities are just averages over predictions produced by all K models.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Step 1)\nstruct FittedEnsemble <: Models.FittedModel\n    ùìú::AbstractArray\nend\n\n# Step 2)\nlogits(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.flatten(Flux.stack([nn(X) for nn in ùë¥.ùìú],1)),dims=1)\nprobs(ùë¥::FittedEnsemble, X::AbstractArray) = mean(Flux.flatten(Flux.stack([œÉ.(nn(X)) for nn in ùë¥.ùìú],1)),dims=1)\n\nùë¥=FittedEnsemble(ùìú);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Again we plot the predicted probabilities in the feature domain. As expected the ensemble is more conservative because it incorporates uncertainty: the predicted probabilities splash out more than before, especially in regions that are not populated by samples.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"plt = plot_contour(X',y,ùë¥);\nsavefig(plt, \"www/models_ensemble_contour.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Finally, we use the GreedyGenerator for the counterfactual search. For the same desired threshold gamma as before, the counterfactual ends up somewhat closer to a cluster of original samples. In other words we end up providing more realisitic albeit likely more costly recourse.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"generator = GreedyGenerator(0.25,20,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"Deep ensemble\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/models_greedy_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"CurrentModule = CounterfactualExplanations ","category":"page"},{"location":"tutorials/binary/#Recourse-for-binary-targets","page":"Binary target","title":"Recourse for binary targets","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using Flux, Random, Plots, PlotThemes, CounterfactualExplanations\ntheme(:wong)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"LogLevel(1)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"To understand the core functionality of CounterfactualExplanations.jl we will look at two example use cases of the generate_counterfactual function. This function takes a structure of type Generator as its main argument. Users can utilize one of the default generators: GenericGenerator <: Generator, GreedyGenerator <: Generator. Alternatively, users can also create their own custom generator. ","category":"page"},{"location":"tutorials/binary/#Default-generators","page":"Binary target","title":"Default generators","text":"","category":"section"},{"location":"tutorials/binary/#GenericGenerator","page":"Binary target","title":"GenericGenerator","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Let tin01 denote the target label, M the model (classifier) and underlinexinmathbbR^D the vector of counterfactual features. In order to generate recourse the GenericGenerator optimizes the following objective function through steepest descent","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"underlinex = arg min_underlinex  ell(M(underlinex)t) + lambda h(underlinex)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"where ell denotes some loss function targeting the deviation between the target label and the predicted label and h(cdot) as a complexity penality generally addressing the realism or cost of the proposed counterfactual. ","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Let's generate some toy data:","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"# Some random data:\nRandom.seed!(1234);\nN = 25\nw = [1.0 1.0]# true coefficients\nb = 0\nx, y = toy_data_linear(N)\nX = hcat(x...)\nplt = plot()\nplt = plot_data!(plt,X',y);\nsavefig(plt, \"www/binary_samples.png\")","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"For this toy data we will now implement algorithmic recourse as follows:","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Use the coefficients w and b to define our model using CounterfactualExplanations.Models.LogisticModel(w, b).\nDefine our GenericGenerator.\nGenerate recourse.","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using CounterfactualExplanations.Models: LogisticModel, probs \n# Logit model:\nùë¥ = LogisticModel(w, [b])\n# Randomly selected factual:\nRandom.seed!(123);\nxÃÖ = X[:,rand(1:size(X)[2])]\nyÃÖ = round(probs(ùë¥, xÃÖ)[1])\ntarget = ifelse(yÃÖ==1.0,0.0,1.0) # opposite label as target\nŒ≥ = 0.75 # desired level of confidence","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"0.75","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"plt = plot_contour(X',y,ùë¥;title=\"Posterior predictive - Plugin\")\nsavefig(plt, \"www/binary_contour.png\");","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"# Define Generator:\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\n# Generate recourse:\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Now let's plot the resulting counterfactual path in the 2-D feature space (left) and the predicted probability (right):","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"Posterior predictive - Plugin\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/binary_generic_recourse.gif\", fps=25);","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"},{"location":"tutorials/binary/#GreedyGenerator","page":"Binary target","title":"GreedyGenerator","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Next we will repeat the exercise above, but instead use the GreedyGenerator in the context of a Bayesian classifier. This generator is greedy in the sense that it simply chooses the most salient feature underlinexd where d=argmax_d in 1D nabla_underlinex ell(M(underlinex)t) and perturbs it by a fixed amount delta. In other words, optimization is penalty-free. This is possible in the Bayesian context, because maximizing the predictive probability gamma corresponds to minimizing the predictive uncertainty: by construction the generated counterfactual will therefore be realistic (low epistemic uncertainty) and unambiguous (low aleotoric uncertainty).","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using LinearAlgebra\nŒ£ = Symmetric(reshape(randn(9),3,3).*0.01 + UniformScaling(1)) # MAP covariance matrix\nŒº = hcat(b, w)\nùë¥ = CounterfactualExplanations.Models.BayesianLogisticModel(Œº, Œ£);\ngenerator = GreedyGenerator(0.25,15,:logitbinarycrossentropy,nothing)\nrecourse = generate_counterfactual(generator, xÃÖ, ùë¥, target, Œ≥); # generate recourse","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Once again we plot the resulting counterfactual path (left) and changes in the predicted probability (right). For the Bayesian classifier predicted probabilities splash out: uncertainty increases in regions with few samples. Note how the greedy approach selects the same most salient feature over and over again until its exhausted (i.e. it has been chosen GreedyGenerator.n times).","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"T = size(recourse.path)[1]\nX_path = reduce(hcat,recourse.path)\nyÃÇ = CounterfactualExplanations.target_probs(probs(recourse.ùë¥, X_path),target)\np1 = plot_contour(X',y,ùë¥;clegend=false, title=\"Posterior predictive - Laplace\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t][1]], [recourse.path[t][2]], ms=5, color=Int(yÃÖ), label=\"\")\n    p2 = plot(1:t, yÃÇ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(yÃ≤=\" * string(target) * \")\", title=\"Validity\", lc=:black)\n    Plots.abline!(p2,0,Œ≥,label=\"threshold Œ≥\", ls=:dash) # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/binary_greedy_recourse.gif\", fps=25);","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"}]
}
