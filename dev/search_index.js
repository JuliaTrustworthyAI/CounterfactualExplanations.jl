var documenterSearchIndex = {"docs":
[{"location":"tutorials/install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/AlgorithmicRecourse.jl\")","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"To instead install the development version of the package you can run the following command:","category":"page"},{"location":"tutorials/install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.add(url=\"https://github.com/pat-alt/AlgorithmicRecourse.jl\", rev=\"dev\")","category":"page"},{"location":"tutorials/multi/","page":"Recourse for multi-class targets","title":"Recourse for multi-class targets","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/multi/#Recourse-for-multi-class-targets","page":"Recourse for multi-class targets","title":"Recourse for multi-class targets","text":"","category":"section"},{"location":"tutorials/multi/","page":"Recourse for multi-class targets","title":"Recourse for multi-class targets","text":"TO BE COMPLETED","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/#All-functions-and-types","page":"Reference","title":"All functions and types","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#Exported-functions","page":"Reference","title":"Exported functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = false","category":"page"},{"location":"reference/#AlgorithmicRecourse.generate_recourse-Tuple{Generator, AbstractArray, AlgorithmicRecourse.Models.FittedModel, Float64, Float64}","page":"Reference","title":"AlgorithmicRecourse.generate_recourse","text":"generate_recourse(generator::Generator, x̅::AbstractArray, 𝑴::Models.FittedModel, target::Float64, γ::Float64; T=1000)\n\nTakes a recourse generator, the factual sample x̅, the fitted model 𝑴, the target label and its desired threshold probability γ. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generators\n\nw = [1.0,-2.0] # true coefficients\nb = [0]\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\nγ = 0.9\n𝑴 = AlgorithmicRecourse.Models.LogisticModel(w, b);\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse\n\nGreedy generator for Bayesian model\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nx̅ = reshape([-1,0.5],1,2)\ntarget = 1.0\nγ = 0.9\n𝑴 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse\n\nSee also:\n\nGenericGenerator(λ::Float64, ϵ::Float64, τ::Float64, loss::Symbol, 𝑭::Union{Nothing,Vector{Symbol}})\nGreedyGenerator(δ::Float64, n::Int64, loss::Symbol, 𝑭::Union{Nothing,Vector{Symbol}}).\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Generators.Generator","page":"Reference","title":"AlgorithmicRecourse.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Generators.GenericGenerator","page":"Reference","title":"AlgorithmicRecourse.Generators.GenericGenerator","text":"GenericGenerator(λ::Float64, ϵ::Float64, τ::Float64, loss::Symbol, 𝑭::Union{Nothing,Vector{Symbol}})\n\nA constructor for a generic recourse generator. It takes values for the complexity penalty λ, the learning rate ϵ, the tolerance for convergence τ,      the type of loss function to be used in the recourse objective and a mutability constraint mask 𝑭.\n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\n\nSee also:\n\ngenerate_recourse(generator::Generator, x̅::AbstractArray, 𝑴::Models.FittedModel, target::Float64; T=1000)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Generators.GreedyGenerator","page":"Reference","title":"AlgorithmicRecourse.Generators.GreedyGenerator","text":"GreedyGenerator(δ::Float64, n::Int64, loss::Symbol, 𝑭::Union{Nothing,Vector{Symbol}})\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the perturbation size δ, the maximum number of times n that any feature can be changed,      the type of loss function to be used in the recourse objective and a mutability constraint mask 𝑭.\n\nExamples\n\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy, nothing)\n\nSee also:\n\ngenerate_recourse(generator::Generator, x̅::AbstractArray, 𝑴::Models.FittedModel, target::Float64; T=1000)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Losses.hinge_loss-Tuple{Any, Any}","page":"Reference","title":"AlgorithmicRecourse.Losses.hinge_loss","text":"hinge_loss(ŷ, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"},{"location":"reference/#Internal-functions","page":"Reference","title":"Internal functions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPublic = false","category":"page"},{"location":"reference/#AlgorithmicRecourse.Recourse","page":"Reference","title":"AlgorithmicRecourse.Recourse","text":"Recourse(x̲::AbstractArray, y̲::Float64, path::Matrix{Float64}, generator::Generators.Generator, x̅::AbstractArray, y̅::Float64, 𝑴::Models.FittedModel, target::Float64)\n\nCollects all variables relevant to the recourse outcome. \n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.apply_mutability-Tuple{AbstractArray, Vector{Symbol}}","page":"Reference","title":"AlgorithmicRecourse.apply_mutability","text":"apply_mutability(Δx̲::AbstractArray, 𝑭::Vector{Symbol})\n\nApply mutability constraints to Δx̲ based on vector of constraints 𝑭.\n\nExamples\n\n𝑭 = [:both, :increase, :decrease, :none] _mutability([-1,1,-1,1], 𝑭) # all but :none pass _mutability([-1,-1,-1,1], 𝑭) # all but :increase and :none pass _mutability([-1,1,1,1], 𝑭) # all but :decrease and :none pass _mutability([-1,-1,1,1], 𝑭) # only :both passes\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.threshold_reached-Tuple{AlgorithmicRecourse.Models.FittedModel, AbstractArray, Float64, Float64}","page":"Reference","title":"AlgorithmicRecourse.threshold_reached","text":"threshold_reached(𝑴::Models.FittedModel, x̲::AbstractArray, target::Float64, γ::Float64)\n\nChecks if confidence threshold has been reached. \n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.BayesianLogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.BayesianLogisticModel","text":"BayesianLogisticModel(μ::AbstractArray,Σ::AbstractArray)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates μ (coefficients including constant term(s)) and Σ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝑴 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\n\nSee also:\n\nlogits(𝑴::BayesianLogisticModel, X::AbstractArray)\nprobs(𝑴::BayesianLogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.LogisticModel","page":"Reference","title":"AlgorithmicRecourse.Models.LogisticModel","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝑴 = AlgorithmicRecourse.Models.LogisticModel(w, b);\n\nSee also: \n\nlogits(𝑴::LogisticModel, X::AbstractArray)\nprobs(𝑴::LogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝑴::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as [1 X]μ.\n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝑴 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nlogits(𝑴, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.logits","text":"logits(𝑴::LogisticModel, X::AbstractArray)\n\nComputes logits as Xw+b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝑴 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nlogits(𝑴, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝑴::BayesianLogisticModel, X::AbstractArray)\n\nComputes predictive probabilities using a Probit approximation. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nμ = [0, 1.0,-2.0] # MAP coefficients\nΣ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\n𝑴 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\nx = reshape([1,1],1,2)\nprobs(𝑴, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Reference","title":"AlgorithmicRecourse.Models.probs","text":"probs(𝑴::LogisticModel, X::AbstractArray)\n\nComputes predictive probabilities from logits as σ(Xw+b) where 'σ' is the sigmoid function. \n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\n𝑴 = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nprobs(𝑴, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"tutorials/loss/","page":"Loss functions and gradients","title":"Loss functions and gradients","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/loss/#Loss-functions-and-gradients","page":"Loss functions and gradients","title":"Loss functions and gradients","text":"","category":"section"},{"location":"tutorials/loss/","page":"Loss functions and gradients","title":"Loss functions and gradients","text":"TO BE COMPLETED","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmicRecourse","category":"page"},{"location":"#AlgorithmicRecourse","page":"Home","title":"AlgorithmicRecourse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AlgorithmicRecourse.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for counterfactual explanations (CE) and algorithmic recourse (AR) in Julia. The former (CE) is a common approach towards explaining machine learning models. The latter (AR) uses counterfactual explanations to systematically provide recourse to individuals faced with an undesirable algorithmic outcome. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/models/#Models","page":"Models","title":"Models","text":"","category":"section"},{"location":"tutorials/models/#Default-models","page":"Models","title":"Default models","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"There are currently structures for two default models that can be used with AlgorithmicRecourse.jl:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\nBayesianLogisticModel(μ::AbstractArray,Σ::AbstractArray)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Both take sets of estimated parameters at the point of instantiation: the constructors will not fit a model for you, but assume that you have already estimated the respective model yourself and have access to its parameter estimates. Based on the supplied parameters methods to predict logits and probabilities are already implemented and used in the counterfactual search. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"For the simple logistic regression model logits are computed as a=Xw + b and probabilities are simply sigma(a). For the Bayesian logistic regression model logits are computed as Xmu and the predictive posterior is computed through Laplace approximation.","category":"page"},{"location":"tutorials/models/#Custom-models","page":"Models","title":"Custom models","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Apart from the default models you can use any arbitrary (differentiable) model and generate recourse in the same way as before. Only two steps are necessary to make your own model compatible with AlgorithmicRecourse.jl:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The model needs to be declared as a subtype of AlgorithmicRecourse.Models.FittedModel.\nYou need to extend the functions AlgorithmicRecourse.Models.logits and AlgorithmicRecourse.Models.probs to accept your custom model.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Below we will go through a simple example to see how this can be done in practice. ","category":"page"},{"location":"tutorials/models/#Neural-network","page":"Models","title":"Neural network","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"In this example we will build a simple artificial neural network using Flux.jl for a binary classification task.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Import libraries.\nusing Flux, Plots, Random, PlotThemes, Statistics\ntheme(:juno)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"LogLevel(1)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"First we generate some toy data below. The code that generates this data was borrowed from a great tutorial about Bayesian neural networks provided by Turing.jl, which you may find here. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The plot below shows the generated samples in the 2D feature space where colours indicate the associated labels. Clearly this data is not linearly separable and the default LogisticModel would be ill suited for this classification task.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Number of points to generate.\nN = 80\nM = round(Int, N / 4)\nRandom.seed!(1234)\n\n# Generate artificial data.\nx1s = rand(M) * 4.5; x2s = rand(M) * 4.5; \nxt1s = Array([[x1s[i] + 0.5; x2s[i] + 0.5] for i = 1:M])\nx1s = rand(M) * 4.5; x2s = rand(M) * 4.5; \nappend!(xt1s, Array([[x1s[i] - 5; x2s[i] - 5] for i = 1:M]))\n\nx1s = rand(M) * 4.5; x2s = rand(M) * 4.5; \nxt0s = Array([[x1s[i] + 0.5; x2s[i] - 5] for i = 1:M])\nx1s = rand(M) * 4.5; x2s = rand(M) * 4.5; \nappend!(xt0s, Array([[x1s[i] - 5; x2s[i] + 0.5] for i = 1:M]))\n\n# Store all the data for later.\nxs = [xt1s; xt0s]\nX = hcat(xs...) # bring into tabular format\nts = [ones(2*M); zeros(2*M)]\n\nplt = plot()\n\n# Plot data points.\nfunction plot_data!(plt)\n    x1 = map(e -> e[1], xt1s)\n    y1 = map(e -> e[2], xt1s)\n    x2 = map(e -> e[1], xt0s)\n    y2 = map(e -> e[2], xt0s)\n\n    Plots.scatter!(plt, x1,y1, color=1, clim = (0,1), label=\"y=1\")\n    Plots.scatter!(plt, x2,y2, color=0, clim = (0,1), label=\"y=0\")\nend\n\nplt = plot_data!(plt);\nsavefig(plt, \"www/models_samples.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/#Training-the-model","page":"Models","title":"Training the model","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Instead we will build a simple artificial neural network nn with one hidden layer. For additional resources on how to do deep learning with Flux.jl just have a look at their documentation. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"function build_model(;input_dim=2,n_hidden=32,output_dim=1)\n    \n    # Params:\n    W₁ = input_dim\n    b₁ = n_hidden\n    W₀ = n_hidden\n    b₀ = output_dim\n    \n    nn = Chain(\n        Dense(W₁, b₁, σ),\n        Dense(W₀, b₀))  \n\n    return nn\n\nend\nnn = build_model()\nloss(x, y) = Flux.Losses.logitbinarycrossentropy(nn(x), y)\nps = Flux.params(nn)\ndata = zip(xs,ts);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The code below trains the neural network for the task at hand. The plot shows the (training) loss over time. Note that normally we would be interested in loss with respect to a validation data set. But since we are primarily interested in generated recourse for a trained classifier, here we will just keep things very simple.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Flux.Optimise: update!, ADAM\nopt = ADAM()\nepochs = 200\navg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\n\nusing Plots\nanim = Animation()\nplt = plot(ylim=(0,avg_loss(data)), xlim=(0,epochs), legend=false, xlab=\"Epoch\")\navg_l = []\n\nfor epoch = 1:epochs\n  for d in data\n    gs = gradient(params(nn)) do\n      l = loss(d...)\n    end\n    update!(opt, params(nn), gs)\n  end\n  avg_l = vcat(avg_l,avg_loss(data))\n  plot!(plt, avg_l, color=1, title=\"Average (training) loss\")\n  frame(anim, plt)\nend\n\ngif(anim, \"www/models_loss.gif\");","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The plot below shows the predicted probabilities in the feature domain. Evidently our simple neural network is doing very well on the training data, as explected. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Plot the posterior distribution with a contour plot.\nx_range = collect(range(-6,stop=6,length=25))\ny_range = collect(range(-6,stop=6,length=25))\nZ = [σ.(nn([x, y]))[1] for x=x_range, y=y_range]\nfunction plot_contour(;clegend=true, title=\"\")\n    plt = contourf(x_range, y_range, Z, color=:viridis, legend=clegend, title=title)\n    plot_data!(plt)\nend\nplt = plot_contour();\nsavefig(plt, \"www/models_contour.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/#Generating-recourse","page":"Models","title":"Generating recourse","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now it's game time: we have a fitted model M mathcalX mapsto y and are interested in generating recourse for some individual overlinexinmathcalX. As mentioned above we need to do a bit more work to prepare the model to be used by AlgorithmicRecourse.jl. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"The code below takes care of all of that: in step 1) it declares our model as a subtype of Models.FittedModel and in step 2) it just extends the two functions. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using AlgorithmicRecourse, AlgorithmicRecourse.Models\nimport AlgorithmicRecourse.Models: logits, probs # import functions in order to extend\n\n# Step 1)\nstruct NeuralNetwork <: Models.FittedModel\n    nn::Any\nend\n\n# Step 2)\nlogits(𝑴::NeuralNetwork, X::AbstractArray) = 𝑴.nn(X)\nprobs(𝑴::NeuralNetwork, X::AbstractArray)= σ.(logits(𝑴, X))\n𝑴 = NeuralNetwork(nn)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"NeuralNetwork(Chain(Dense(2, 32, σ), Dense(32, 1)))","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now we just select a random sample from our data and based on its current label we set as our target the opposite label and desired threshold for the predicted probability.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Random\nRandom.seed!(1234)\nx̅ = X[:,rand(1:size(X)[2])]\ny̅ = round(probs(𝑴, x̅)[1])\ntarget = ifelse(y̅==1.0,0.0,1.0) # opposite label as target\nγ = ifelse(target==1.0,0.75,0.25); # desired threshold based on target","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Then finally we use the GenericGenerator to generate recourse. The plot further below shows the resulting counterfactual path.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"generator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"T = size(recourse.path)[1]\nŷ = probs(recourse.𝑴, recourse.path')\np1 = plot_contour(;clegend=false, title=\"Neural network\")\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t,1]], [recourse.path[t,2]], ms=5, color=Int(y̅))\n    p2 = plot(1:t, ŷ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(y̲=1)\", title=\"Validity\")\n    Plots.abline!(p2,0,γ,label=\"threshold γ\") # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/models_generic_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/#Ensemble-of-neural-networks","page":"Models","title":"Ensemble of neural networks","text":"","category":"section"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"In the context of Bayesian classifiers the GreedyGenerator can be used since minimizing the predictive uncertainty acts as a proxy for realism and unambiquity. In other words, if we have a model that incorporates uncertainty, we can generate realistic counterfactuals without the need for a complexity penalty. ","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"One efficient way to produce uncertainty estimates in the context of deep learning is to simply use an ensemble of artificial neural networks (also referred to as deep ensemble). To this end we can use the build_model function from above repeatedly to compose an ensemble of K neural networks:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"K = 50\n\nfunction build_ensemble(K::Int;kw=(input_dim=2,n_hidden=32,output_dim=1))\n    ensemble = [build_model(;kw...) for i in 1:K]\n    return ensemble\nend\n\n𝓜 = build_ensemble(K);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Now we need to be able to train this ensemble, which boils down to training each neural network separately. For this purpose will just summarize the process for training a single neural network (as per above) in a wrapper function:","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"function forward_nn(nn, loss, data, opt; n_epochs=200, plotting=nothing)\n\n    avg_l = []\n    \n    for epoch = 1:n_epochs\n      for d in data\n        gs = gradient(params(nn)) do\n          l = loss(d...)\n        end\n        update!(opt, params(nn), gs)\n      end\n      if !isnothing(plotting)\n        plt = plotting[1]\n        anim = plotting[2]\n        idx = plotting[3]\n        avg_loss(data) = mean(map(d -> loss(d[1],d[2]), data))\n        avg_l = vcat(avg_l,avg_loss(data))\n        if epoch % plotting[4]==0\n          plot!(plt, avg_l, color=idx, alpha=0.3)\n          frame(anim, plt)\n        end\n      end\n    end\n    \nend","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"forward_nn (generic function with 1 method)","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"This wrapper function is used as a subroutine in forward below, which returns are an ensemble of fitted neural networks. The animation below shows the training loss for each of them. As we can see the different networks produce different outcomes: their parameters were initialized at different random values. This is how we introduce stochasticity and hence incorporate uncertainty around our estimates.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"using Statistics\n\nfunction forward(𝓜, data, opt; loss_type=:logitbinarycrossentropy, plot_loss=true, n_epochs=200, plot_every=20) \n\n    anim = nothing\n    if plot_loss\n        anim = Animation()\n        plt = plot(ylim=(0,1), xlim=(0,n_epochs), legend=false, xlab=\"Epoch\", title=\"Average (training) loss\")\n        for i in 1:length(𝓜)\n            nn = 𝓜[i]\n            loss(x, y) = getfield(Flux.Losses,loss_type)(nn(x), y)\n            forward_nn(nn, loss, data, opt, n_epochs=n_epochs, plotting=(plt, anim, i, plot_every))\n        end\n    else\n        plt = nothing\n        for nn in 𝓜\n            loss(x, y) = getfield(Flux.Losses,loss_type)(nn(x), y)\n            forward_nn(nn, loss, data, opt, n_epochs=n_epochs, plt=plt)\n        end\n    end\n\n    return 𝓜, anim\nend;","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"𝓜, anim = forward(𝓜, data, opt, n_epochs=100); # fit the ensemble\ngif(anim, \"www/models_ensemble_loss.gif\", fps=50);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Once again it is straight-forward to make the model compatible with the package. Note that for an ensemble model the predicted logits and probabilities are just averages over predictions produced by all K models.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"# Step 1)\nstruct FittedEnsemble <: Models.FittedModel\n    𝓜::AbstractArray\nend\n\n# Step 2)\nlogits(𝑴::FittedEnsemble, X::AbstractArray) = mean(Flux.flatten(Flux.stack([nn(X) for nn in 𝑴.𝓜],1)),dims=1)\nprobs(𝑴::FittedEnsemble, X::AbstractArray) = mean(Flux.flatten(Flux.stack([σ.(nn(X)) for nn in 𝑴.𝓜],1)),dims=1)\n\n𝑴=FittedEnsemble(𝓜);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Again we plot the predicted probabilities in the feature domain. As expected the ensemble is more conservative because it incorporates uncertainty: the predicted probabilities splash out more than before, especially in regions that are not populated by samples.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Z = [probs(𝑴,[x, y])[1] for x=x_range, y=y_range]\nfunction plot_contour(;clegend=true, title=\"\")\n    plt = contourf(x_range, y_range, Z, color=:viridis, legend=clegend, title=title)\n    plot_data!(plt)\nend\nplt = plot_contour();\nsavefig(plt, \"www/models_ensemble_contour.png\")","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"Finally, we use the GreedyGenerator for the counterfactual search. For the same desired threshold gamma as before, the counterfactual ends up somewhat closer to a cluster of original samples. In other words we end up providing more realisitic albeit likely more costly recourse.","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"generator = GreedyGenerator(0.1,20,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"T = size(recourse.path)[1]\nŷ = probs(recourse.𝑴, recourse.path')\np1 = plot_contour(;clegend=false, title=\"Deep Ensemble\")\nt = 1\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t,1]], [recourse.path[t,2]], ms=5, color=Int(y̅))\n    p2 = plot(1:t, ŷ[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(y̲=1)\", title=\"Validity\")\n    Plots.abline!(p2,0,γ,label=\"threshold γ\") # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/models_greedy_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/models/","page":"Models","title":"Models","text":"(Image: )","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/binary/#Generating-recourse","page":"Binary target","title":"Generating recourse","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using Flux\nusing Random\nusing Plots\nusing PlotThemes\ntheme(:juno)\nusing Logging\ndisable_logging(Logging.Info)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"LogLevel(1)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"To understand the core functionality of AlgorithmicRecourse.jl we will look at two example use cases of the generate_recourse function. This function takes a structure of type Generator as its main argument. Users can utilize one of the default generators: GenericGenerator <: Generator, GreedyGenerator <: Generator. Alternatively, users can also create their own custom generator. ","category":"page"},{"location":"tutorials/binary/#Default-generators","page":"Binary target","title":"Default generators","text":"","category":"section"},{"location":"tutorials/binary/#GenericGenerator","page":"Binary target","title":"GenericGenerator","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Let tin01 denote the target label, M the model (classifier) and underlinexinmathbbR^D the vector of counterfactual features. In order to generate recourse the GenericGenerator optimizes the following objective function through steepest descent","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"underlinex = arg min_underlinex  ell(M(underlinex)t) + lambda h(underlinex)","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"where ell denotes some loss function targeting the deviation between the target label and the predicted label and h(cdot) as a complexity penality generally addressing the realism or cost of the proposed counterfactual. ","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Let's generate some toy data:","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"# Some random data:\nRandom.seed!(1234);\nN = 25\nw = reshape([1.0,-2.0],2,1) # true coefficients\nb = 0\nX = reshape(randn(2*N),N,2).*1 # random features\ny = Int.(round.(Flux.σ.(X*w .+ b))); # label based on sigmoid\n# Choose sample and plot:\nx̅ = reshape(X[5,:],1,2);","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"For this toy data we will now implement algorithmic recourse as follows:","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Use the coefficients w and b to define our model using AlgorithmicRecourse.Models.LogisticModel(w, b).\nDefine our GenericGenerator.\nGenerate recourse.","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using AlgorithmicRecourse\n𝑴 = AlgorithmicRecourse.Models.LogisticModel(w, [b]);\ny̅ = round.(AlgorithmicRecourse.Models.probs(𝑴, x̅))[1]\ntarget = ifelse(y̅==1.0,0.0,1.0)\nγ = ifelse(target==1.0,0.75,0.25)\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Now let's plot the resulting counterfactual path in the 2-D feature space (left) and the predicted probability (right):","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"x1 = (minimum(X[:,1])-1):0.1:(maximum(X[:,1])+1)\nx2 = (minimum(X[:,2])-1):0.1:(maximum(X[:,2])+1)\np1 = Plots.contourf(\n    x1,x2,(x, y) -> AlgorithmicRecourse.Models.probs(recourse.𝑴, reshape([x,y],(1,2)))[1],\n    color = :viridis,\n    linewidth = 0,\n    legend=false\n)\nscatter!(p1,X[:,1],X[:,2],legend=false,color=y,title=\"Logistic Regression\") # features\nPlots.abline!(p1, -w[1]/w[2],0,color=\"black\") # decision boundary\nT = size(recourse.path)[1]\nprobs = AlgorithmicRecourse.Models.probs(recourse.𝑴, recourse.path)\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t,1]], [recourse.path[t,2]], ms=5, color=Int(y̅))\n    p2 = plot(1:t, probs[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(y̲=1)\", title=\"Validity\")\n    Plots.abline!(p2,0,γ,label=\"threshold γ\") # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/generic_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"},{"location":"tutorials/binary/#GreedyGenerator","page":"Binary target","title":"GreedyGenerator","text":"","category":"section"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Next we will repeat the exercise above, but instead use the GreedyGenerator in the context of a Bayesian classifier. This generator is greedy in the sense that it simply chooses the most salient feature underlinexd where d=argmax_d in 1D nabla_underlinex ell(M(underlinex)t) and perturbs it by a fixed amount delta. In other words, optimization is penalty-free. This is possible in the Bayesian context, because maximizing the predictive probability gamma corresponds to minimizing the predictive uncertainty: by construction the generated counterfactual will therefore be realistic (low epistemic uncertainty) and unambiguous (low aleotoric uncertainty).","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"using LinearAlgebra\nΣ = Symmetric(reshape(randn(9),3,3).*0.01 + UniformScaling(1)) # MAP covariance matrix\nμ = vcat(b, w)\n𝑴 = AlgorithmicRecourse.Models.BayesianLogisticModel(μ, Σ);\ngenerator = GreedyGenerator(0.1,12,:logitbinarycrossentropy,nothing)\nrecourse = generate_recourse(generator, x̅, 𝑴, target, γ); # generate recourse","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"Once again we plot the resulting counterfactual path (left) and changes in the predicted probability (right). For the Bayesian classifier predicted probabilities splash out: uncertainty increases in regions with few samples. Note how the greedy approach selects the same most salient feature over and over again until its exhausted (i.e. it has been chosen GreedyGenerator.n times).","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"p1 = Plots.contourf(\n    x1,x2,(x, y) -> AlgorithmicRecourse.Models.probs(recourse.𝑴, reshape([x,y],(1,2)))[1],\n    color = :viridis,\n    linewidth = 0,\n    legend=false\n)\nscatter!(p1,X[:,1],X[:,2],legend=false,color=y,title=\"Bayesian Logistic Regression\") # features\nPlots.abline!(p1, -w[1]/w[2],0,color=\"black\") # decision boundary\nT = size(recourse.path)[1]\nprobs = AlgorithmicRecourse.Models.probs(recourse.𝑴, recourse.path)\nanim = @animate for t in 1:T\n    scatter!(p1, [recourse.path[t,1]], [recourse.path[t,2]], ms=5, color=Int(y̅))\n    p2 = plot(1:t, probs[1:t], xlim=(0,T), ylim=(0, 1), label=\"p(y̲=1)\", title=\"Validity\")\n    Plots.abline!(p2,0,γ,label=\"threshold γ\") # decision boundary\n    plot(p1,p2,size=(800,400))\nend\ngif(anim, \"www/greedy_recourse.gif\", fps=5);","category":"page"},{"location":"tutorials/binary/","page":"Binary target","title":"Binary target","text":"(Image: )","category":"page"}]
}
