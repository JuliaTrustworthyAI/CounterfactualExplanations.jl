var documenterSearchIndex = {"docs":
[{"location":"tutorials/quick/","page":"Quick start","title":"Quick start","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"tutorials/quick/#Quick-start","page":"Quick start","title":"Quick start","text":"","category":"section"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/reference/#All-functions-and-types","page":"Full references","title":"All functions and types","text":"","category":"section"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"","category":"page"},{"location":"reference/reference/","page":"Full references","title":"Full references","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = true","category":"page"},{"location":"reference/reference/#AlgorithmicRecourse.Recourse","page":"Full references","title":"AlgorithmicRecourse.Recourse","text":"Recourse(xÌ²::AbstractArray, yÌ²::Float64, path::Matrix{Float64}, generator::Generators.Generator, ğ“˜::AbstractArray, xÌ…::AbstractArray, yÌ…::Float64, ğ“œ::Models.FittedModel, target::Float64)\n\nCollects all variables relevant to the recourse outcome. \n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.threshold_reached-Tuple{AlgorithmicRecourse.Models.FittedModel, AbstractArray, Float64, Float64}","page":"Full references","title":"AlgorithmicRecourse.threshold_reached","text":"threshold_reached(ğ“œ::Models.FittedModel, xÌ²::AbstractArray, target::Float64, Î³::Float64)\n\nChecks if confidence threshold has been reached. \n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.BayesianLogisticModel","page":"Full references","title":"AlgorithmicRecourse.Models.BayesianLogisticModel","text":"BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a Bayesian logistic classifier based on maximum a posteriori (MAP) estimates Î¼ (coefficients including constant term(s)) and Î£ (covariance matrix). \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\n\nSee also:\n\nlogits(ğ“œ::BayesianLogisticModel, X::AbstractArray)\nprobs(ğ“œ::BayesianLogisticModel, X::AbstractArray)\nconfidence(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.Models.LogisticModel","page":"Full references","title":"AlgorithmicRecourse.Models.LogisticModel","text":"LogisticModel(w::AbstractArray,b::AbstractArray)\n\nConstructs a logistic classifier based on arrays containing coefficients w and constant terms b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\n\nSee also: \n\nlogits(ğ“œ::LogisticModel, X::AbstractArray)\nprobs(ğ“œ::LogisticModel, X::AbstractArray)\n\n\n\n\n\n","category":"type"},{"location":"reference/reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.logits","text":"logits(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\nComputes logits as [1 X]Î¼.\n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\nx = reshape([1,1],1,2)\nlogits(ğ“œ, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.logits-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.logits","text":"logits(ğ“œ::LogisticModel, X::AbstractArray)\n\nComputes logits as Xw+b.\n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nlogits(ğ“œ, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.BayesianLogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.probs","text":"probs(ğ“œ::BayesianLogisticModel, X::AbstractArray)\n\nComputes predictive probabilities using a Probit approximation. \n\nExamples\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\nx = reshape([1,1],1,2)\nprobs(ğ“œ, x)\n\nSee also BayesianLogisticModel(w::AbstractArray,b::AbstractArray)\n\n\n\n\n\n","category":"method"},{"location":"reference/reference/#AlgorithmicRecourse.Models.probs-Tuple{AlgorithmicRecourse.Models.LogisticModel, AbstractArray}","page":"Full references","title":"AlgorithmicRecourse.Models.probs","text":"probs(ğ“œ::LogisticModel, X::AbstractArray)\n\nComputes predictive probabilities from logits as Ïƒ(Xw+b) where 'Ïƒ' is the sigmoid function. \n\nExamples\n\nw = [1.0,-2.0] # estimated coefficients\nb = [0] # estimated constant\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\nx = reshape([1,1],1,2)\nprobs(ğ“œ, x)\n\nSee also LogisticModel(w::AbstractArray,b::AbstractArray).\n\n\n\n\n\n","category":"method"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = AlgorithmicRecourse","category":"page"},{"location":"#AlgorithmicRecourse","page":"Home","title":"AlgorithmicRecourse","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for AlgorithmicRecourse.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"A package for counterfactual explanations (CE) and algorithmic recourse (AR) in Julia. The former (CE) is a common approach towards explaining machine learning models. The latter (AR) uses counterfactual explanations to systematically provide recourse to individuals faced with an undesirable algorithmic outcome. ","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is in its early stages of development and not yet registered. In the meantime it can be installed as follows:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"https://github.com/pat-alt/AlgorithmicRecourse.jl\")","category":"page"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"CurrentModule = AlgorithmicRecourse ","category":"page"},{"location":"reference/exported/#Exported-functions-and-types","page":"Exported","title":"Exported functions and types","text":"","category":"section"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"Private = false","category":"page"},{"location":"reference/exported/","page":"Exported","title":"Exported","text":"Modules = [AlgorithmicRecourse, AlgorithmicRecourse.Generators, AlgorithmicRecourse.Models, AlgorithmicRecourse.Losses]\nPrivate = false","category":"page"},{"location":"reference/exported/#AlgorithmicRecourse.generate_recourse-Tuple{Generator, AbstractArray, AlgorithmicRecourse.Models.FittedModel, Float64, Float64}","page":"Exported","title":"AlgorithmicRecourse.generate_recourse","text":"generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64, Î³::Float64; T=1000, ğ“˜=[])\n\nTakes a recourse generator, the factual sample xÌ…, the fitted model ğ“œ, the target label and its desired threshold probability Î³. Returns the generated recourse (an object of type Recourse).\n\nExamples\n\nGeneric generators\n\nw = [1.0,-2.0] # true coefficients\nb = [0]\nxÌ… = reshape([-1,0.5],1,2)\ntarget = 1.0\nÎ³ = 0.9\nğ“œ = AlgorithmicRecourse.Models.LogisticModel(w, b);\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, xÌ…, ğ“œ, target, Î³); # generate recourse\n\nGreedy generator for Bayesian model\n\nusing Random, LinearAlgebra\nRandom.seed!(1234)\nÎ¼ = [0, 1.0,-2.0] # MAP coefficients\nÎ£ = Symmetric(reshape(randn(9),3,3).*0.1 + UniformScaling(1.0)) # MAP covariance matrix\nxÌ… = reshape([-1,0.5],1,2)\ntarget = 1.0\nÎ³ = 0.9\nğ“œ = AlgorithmicRecourse.Models.BayesianLogisticModel(Î¼, Î£);\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy)\nrecourse = generate_recourse(generator, xÌ…, ğ“œ, target, Î³); # generate recourse\n\nSee also GenericGenerator(Î»::Float64, Ïµ::Float64, Ï„::Float64, loss::Symbol), GreedyGenerator(Î“::Float64, Î´::Float64, n::Int64, loss::Symbol).\n\n\n\n\n\n","category":"method"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.Generator","page":"Exported","title":"AlgorithmicRecourse.Generators.Generator","text":"Generator\n\nAn abstract type that serves as the base type for recourse generators. \n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.GenericGenerator","page":"Exported","title":"AlgorithmicRecourse.Generators.GenericGenerator","text":"GenericGenerator(Î»::Float64, Ïµ::Float64, Ï„::Float64, loss::Symbol)\n\nA constructor for a generic recourse generator.  It takes values for the complexity penalty Î», the learning rate Ïµ, the tolerance for convergence Ï„ and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GenericGenerator(0.1,0.1,1e-5,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64; T=1000, ğ“˜=[]).\n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Generators.GreedyGenerator","page":"Exported","title":"AlgorithmicRecourse.Generators.GreedyGenerator","text":"GreedyGenerator(Î´::Float64, n::Int64, loss::Symbol)\n\nConstructs a greedy recourse generator for Bayesian models. It takes values for the perturbation size Î´, the maximum number of times n that any feature can be changed  and the type of loss function to be used in the recourse objective. \n\nExamples\n\ngenerator = GreedyGenerator(0.01,20,:logitbinarycrossentropy)\n\nSee also generate_recourse(generator::Generator, xÌ…::AbstractArray, ğ“œ::Models.FittedModel, target::Float64; T=1000, ğ“˜=[]).\n\n\n\n\n\n","category":"type"},{"location":"reference/exported/#AlgorithmicRecourse.Losses.hinge_loss-Tuple{Any, Any}","page":"Exported","title":"AlgorithmicRecourse.Losses.hinge_loss","text":"hinge_loss(yÌ‚, y)\n\nUses Flux.Losses.hinge_loss to compute Hinge loss. If provided labels are in {0,1} they are mapped to {-1,1}. \n\n\n\n\n\n","category":"method"}]
}
