<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Handling Data · CounterfactualExplanations.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://juliatrustworthyai.github.io/CounterfactualExplanations.jl/tutorials/data_preprocessing/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.svg" alt="CounterfactualExplanations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">CounterfactualExplanations.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">🏠 Home</a></li><li><span class="tocitem">🫣 Tutorials</span><ul><li><a class="tocitem" href="../">Overview</a></li><li><a class="tocitem" href="../simple_example/">Simple Example</a></li><li><a class="tocitem" href="../whistle_stop/">Whiste-Stop Tour</a></li><li class="is-active"><a class="tocitem" href>Handling Data</a><ul class="internal"><li><a class="tocitem" href="#Basic-Functionality"><span>Basic Functionality</span></a></li><li><a class="tocitem" href="#Categorical-Features"><span>Categorical Features</span></a></li><li><a class="tocitem" href="#Immutable-Features"><span>Immutable Features</span></a></li></ul></li><li><a class="tocitem" href="../data_catalogue/">Data Catalogue</a></li><li><a class="tocitem" href="../models/">Handling Models</a></li><li><a class="tocitem" href="../model_catalogue/">Model Catalogue</a></li><li><a class="tocitem" href="../generators/">Handling Generators</a></li><li><a class="tocitem" href="../evaluation/">Evaluating Explanations</a></li><li><a class="tocitem" href="../benchmarking/">Benchmarking Explanations</a></li><li><a class="tocitem" href="../parallelization/">Parallelization</a></li></ul></li><li><span class="tocitem">🤓 Explanation</span><ul><li><a class="tocitem" href="../../explanation/">Overview</a></li><li><a class="tocitem" href="../../explanation/architecture/">Package Architecture</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Generators</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/generators/overview/">Overview</a></li><li><a class="tocitem" href="../../explanation/generators/generic/">Generic</a></li><li><a class="tocitem" href="../../explanation/generators/clap_roar/">ClaPROAR</a></li><li><a class="tocitem" href="../../explanation/generators/clue/">CLUE</a></li><li><a class="tocitem" href="../../explanation/generators/dice/">DiCE</a></li><li><a class="tocitem" href="../../explanation/generators/feature_tweak/">FeatureTweak</a></li><li><a class="tocitem" href="../../explanation/generators/gravitational/">Gravitational</a></li><li><a class="tocitem" href="../../explanation/generators/greedy/">Greedy</a></li><li><a class="tocitem" href="../../explanation/generators/growing_spheres/">GrowingSpheres</a></li><li><a class="tocitem" href="../../explanation/generators/probe/">PROBE</a></li><li><a class="tocitem" href="../../explanation/generators/revise/">REVISE</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Optimisers</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../explanation/optimisers/overview/">Overview</a></li><li><a class="tocitem" href="../../explanation/optimisers/jsma/">JSMA</a></li></ul></li><li><a class="tocitem" href="../../explanation/categorical/">Categorical Features</a></li></ul></li><li><span class="tocitem">🫡 How-To ...</span><ul><li><a class="tocitem" href="../../how_to_guides/">Overview</a></li><li><a class="tocitem" href="../../how_to_guides/custom_generators/">... add custom generators</a></li><li><a class="tocitem" href="../../how_to_guides/custom_models/">... add custom models</a></li></ul></li><li><a class="tocitem" href="../../reference/">🧐 Reference</a></li><li><a class="tocitem" href="../../contribute/">🛠 Contribute</a></li><li><a class="tocitem" href="../../assets/resources/">📚 Additional Resources</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">🫣 Tutorials</a></li><li class="is-active"><a href>Handling Data</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Handling Data</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/juliatrustworthyai/CounterfactualExplanations.jl/blob/main/docs/src/tutorials/data_preprocessing.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Handling-Data"><a class="docs-heading-anchor" href="#Handling-Data">Handling Data</a><a id="Handling-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Handling-Data" title="Permalink"></a></h1><p>The package works with custom data containers that contain the input and output data as well as information about the type and mutability of features. In this tutorial, we will see how data can be prepared for use with the package.</p><h2 id="Basic-Functionality"><a class="docs-heading-anchor" href="#Basic-Functionality">Basic Functionality</a><a id="Basic-Functionality-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Functionality" title="Permalink"></a></h2><p>To demonstrate the basic way to prepare data, let’s look at a standard benchmark dataset: Fisher’s classic iris dataset. We can use <code>MLDatasets</code> to load this data.</p><pre><code class="language-julia hljs">dataset = Iris()</code></pre><p>Our data constructor <code>CounterfactualData</code> needs at least two inputs: features <code>X</code> and targets <code>y</code>.</p><pre><code class="language-julia hljs">X = dataset.features
y = dataset.targets</code></pre><p>Next, we convert the input data to a <code>Tables.MatrixTable</code> (following <code>MLJ.jl</code>) convention. Concerning the target variable, we just assign grab the first column of the data frame.</p><pre><code class="language-julia hljs">X = table(Tables.matrix(X))
y = y[:,1]</code></pre><p>Now we can feed these two ingredients to our constructor:</p><pre><code class="language-julia hljs">counterfactual_data = CounterfactualData(X, y)</code></pre><p>Under the hood, the constructor performs basic preprocessing steps. For example, the output variable <code>y</code> is automatically one-hot encoded:</p><pre><code class="language-julia hljs">counterfactual_data.y</code></pre><pre><code class="nohighlight hljs">3×150 Matrix{Bool}:
 1  1  1  1  1  1  1  1  1  1  1  1  1  …  0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0     0  0  0  0  0  0  0  0  0  0  0  0
 0  0  0  0  0  0  0  0  0  0  0  0  0     1  1  1  1  1  1  1  1  1  1  1  1</code></pre><p>Similarly, a transformer used to scale continuous input features is automatically fitted:</p><pre><code class="language-julia hljs">counterfactual_data.dt</code></pre><pre><code class="nohighlight hljs">ZScoreTransform{Float64, Vector{Float64}}(4, 2, [5.843333333333335, 3.0540000000000007, 3.7586666666666693, 1.1986666666666672], [0.8280661279778629, 0.4335943113621737, 1.7644204199522617, 0.7631607417008414])</code></pre><h2 id="Categorical-Features"><a class="docs-heading-anchor" href="#Categorical-Features">Categorical Features</a><a id="Categorical-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Categorical-Features" title="Permalink"></a></h2><p>For the counterfactual search, it is important to distinguish between continuous and categorical features. This is because categorical features cannot be perturbed arbitrarily: they can take specific discrete values, but not just any value on the real line.</p><p>Consider the following example:</p><pre><code class="language-julia hljs">y = rand([1,0],4)
X = (
    name=categorical([&quot;Danesh&quot;, &quot;Lee&quot;, &quot;Mary&quot;, &quot;John&quot;]),
    grade=categorical([&quot;A&quot;, &quot;B&quot;, &quot;A&quot;, &quot;C&quot;], ordered=true),
    sex=categorical([&quot;male&quot;,&quot;female&quot;,&quot;male&quot;,&quot;male&quot;]),
    height=[1.85, 1.67, 1.5, 1.67],
)
schema(X)</code></pre><pre><code class="nohighlight hljs">┌────────┬──────────────────┬──────────────────────────────────┐
│ names  │ scitypes         │ types                            │
├────────┼──────────────────┼──────────────────────────────────┤
│ name   │ Multiclass{4}    │ CategoricalValue{String, UInt32} │
│ grade  │ OrderedFactor{3} │ CategoricalValue{String, UInt32} │
│ sex    │ Multiclass{2}    │ CategoricalValue{String, UInt32} │
│ height │ Continuous       │ Float64                          │
└────────┴──────────────────┴──────────────────────────────────┘</code></pre><p>Typically, in the context of Unserpervised Learning, categorical features are one-hot or dummy encoded. To this end, we could use <code>MLJ</code>, for example:</p><pre><code class="language-julia hljs">hot = OneHotEncoder()
mach = MLJBase.fit!(machine(hot, X))
W = MLJBase.transform(mach, X)
X = permutedims(MLJBase.matrix(W))</code></pre><p>In all likelihood, this pre-processing step already happens at the stage, when the supervised model is trained. Since our counterfactual generators need to work in the same feature domain as the model they are intended to explain, we assume that categorical features are already encoded.</p><p>The <code>CounterfactualData</code> constructor takes two optional arguments that can be used to specify the indices of categorical and continuous features. By default, all features are assumed to be continuous. For categorical features, the constructor expects an array of arrays of integers (<code>Vector{Vector{Int}}</code>) where each subarray includes the indices of all one-hot encoded rows related to a single categorical feature. In the example above, the <code>name</code> feature is one-hot encoded across rows 1, 2, 3 and 4 of <code>X</code>, the <code>grade</code> feature is encoded across the following three rows, etc.</p><pre><code class="language-julia hljs">schema(W)</code></pre><pre><code class="nohighlight hljs">┌──────────────┬────────────┬─────────┐
│ names        │ scitypes   │ types   │
├──────────────┼────────────┼─────────┤
│ name__Danesh │ Continuous │ Float64 │
│ name__John   │ Continuous │ Float64 │
│ name__Lee    │ Continuous │ Float64 │
│ name__Mary   │ Continuous │ Float64 │
│ grade__A     │ Continuous │ Float64 │
│ grade__B     │ Continuous │ Float64 │
│ grade__C     │ Continuous │ Float64 │
│ sex__female  │ Continuous │ Float64 │
│ sex__male    │ Continuous │ Float64 │
│ height       │ Continuous │ Float64 │
└──────────────┴────────────┴─────────┘</code></pre><p>The code chunk below assigns the categorical and continuous feature indices:</p><pre><code class="language-julia hljs">features_categorical = [
    [1,2,3,4],      # name
    [5,6,7],        # grade
    [8,9]           # sex
]
features_continuous = [10]</code></pre><p>When instantiating the data container, these indices just need to be supplied as keyword arguments:</p><pre><code class="language-julia hljs">counterfactual_data = CounterfactualData(
    X,y;
    features_categorical = features_categorical,
    features_continuous = features_continuous
)</code></pre><p>This will ensure that the discrete domain of categorical features is respected in the counterfactual search. We achieve this through a form of Projected Gradient Descent and it works for any of our counterfactual generators.</p><h3 id="Example"><a class="docs-heading-anchor" href="#Example">Example</a><a id="Example-1"></a><a class="docs-heading-anchor-permalink" href="#Example" title="Permalink"></a></h3><p>To see this in action, let’s load some synthetic data using <code>MLJ</code>:</p><pre><code class="language-julia hljs">N = 1000
X, ys = MLJBase.make_blobs(N, 2; centers=2, as_table=false, center_box=(-5 =&gt; 5), cluster_std=0.5)
ys .= ys.==2</code></pre><p>Next, we generate a synthetic categorical feature based on the output variable. First, we define the discrete levels:</p><pre><code class="language-julia hljs">cat_values = [&quot;X&quot;,&quot;Y&quot;,&quot;Z&quot;]</code></pre><p>Next, we impose that the categorical feature is most likely to take the first discrete level, namely X, whenever <code>y</code> is equal to <span>$1$</span>.</p><pre><code class="language-julia hljs">xcat = map(ys) do y
    if y==1
        x = sample(cat_values, Weights([0.8,0.1,0.1]))
    else
        x = sample(cat_values, Weights([0.1,0.1,0.8]))
    end
end
xcat = categorical(xcat)
X = (
    x1 = X[:,1],
    x2 = X[:,2],
    x3 = xcat
)
schema(X)</code></pre><p>As above, we use a <code>OneHotEncoder</code> to transform the data:</p><pre><code class="language-julia hljs">hot = OneHotEncoder()
mach = MLJBase.fit!(machine(hot, X))
W = MLJBase.transform(mach, X)
schema(W)
X = permutedims(MLJBase.matrix(W))</code></pre><p>Finally, we assign the categorical indices and instantiate our data container:</p><pre><code class="language-julia hljs">features_categorical = [collect(3:size(X,1))]
counterfactual_data = CounterfactualData(
    X,ys&#39;;
    features_categorical = features_categorical,
)</code></pre><p>With the data pre-processed we can use the <a href="tutorials/@ref"><code>fit_model</code></a> function to train a simple classifier:</p><pre><code class="language-julia hljs">M = fit_model(counterfactual_data, :Linear)</code></pre><p>Now it is finally time to generate counterfactuals. We first define <span>$1$</span> as our target and then choose a random sample from the non-target class:</p><pre><code class="language-julia hljs">target = 1
factual = 0
chosen = rand(findall(predict_label(M, counterfactual_data) .== factual))
x = select_factual(counterfactual_data, chosen) </code></pre><pre><code class="nohighlight hljs">5×1 Matrix{Float64}:
 -2.943347196681443
  0.5782962763892812
  0.0
  0.0
  1.0</code></pre><p>The factual <code>x</code> belongs to group Z.</p><p>We generate a counterfactual for <code>x</code> using the standard API call:</p><pre><code class="language-julia hljs">generator = GenericGenerator()
ce = generate_counterfactual(x, target, counterfactual_data, M, generator)</code></pre><pre><code class="nohighlight hljs">Convergence: ✅

 after 5 steps.</code></pre><p>The search yields the following counterfactual:</p><pre><code class="language-julia hljs">x′ = counterfactual(ce)</code></pre><pre><code class="nohighlight hljs">5-element Vector{Float64}:
 0.014063284971383538
 0.7482142358817984
 1.0
 0.0
 0.0</code></pre><p>It belongs to group X.</p><p>This is intuitive because by construction the categorical variable is most likely to take that value when <code>y</code> is equal to the target outcome.</p><h2 id="Immutable-Features"><a class="docs-heading-anchor" href="#Immutable-Features">Immutable Features</a><a id="Immutable-Features-1"></a><a class="docs-heading-anchor-permalink" href="#Immutable-Features" title="Permalink"></a></h2><p>In practice, features usually cannot be perturbed arbitrarily. Suppose, for example, that one of the features used by a bank to predict the creditworthiness of its clients is <em>gender</em>. If a counterfactual explanation for the prediction model indicates that female clients should change their gender to improve their creditworthiness, then this is an interesting insight (it reveals gender bias), but it is not usually an actionable transformation in practice. In such cases, we may want to constrain the mutability of features to ensure actionable and realistic recourse.</p><p>To illustrate how this can be implemented in <code>CounterfactualExplanations.jl</code> we will continue to work with the synthetic data from the previous section. Mutability of features can be defined in terms of four different options: 1) the feature is mutable in both directions, 2) the feature can only increase (e.g. age), 3) the feature can only decrease (e.g. time left until your next deadline) and 4) the feature is not mutable (e.g. skin colour, ethnicity, …). To specify which category a feature belongs to, you can pass a vector of symbols containing the mutability constraints at the pre-processing stage. For each feature you can choose from these four options: <code>:both</code> (mutable in both directions), <code>:increase</code> (only up), <code>:decrease</code> (only down) and <code>:none</code> (immutable). By default, <code>nothing</code> is passed to that keyword argument and it is assumed that all features are mutable in both directions.</p><p>Below we impose that the second feature is immutable.</p><pre><code class="language-julia hljs">counterfactual_data = load_linearly_separable()
M = fit_model(counterfactual_data, :Linear)
counterfactual_data.mutability = [:both, :none]</code></pre><pre><code class="language-julia hljs">target = 2
factual = 1
chosen = rand(findall(predict_label(M, counterfactual_data) .== factual))
x = select_factual(counterfactual_data, chosen) 
ce = generate_counterfactual(x, target, counterfactual_data, M, generator)</code></pre><p>The resulting counterfactual path is shown in the chart below. Since only the first feature can be perturbed, the sample can only move along the horizontal axis.</p><pre><code class="language-julia hljs">plot(ce)</code></pre><p><img src="../data_preprocessing_files/figure-commonmark/fig-mutability-output-1.svg" alt="Figure 1: Counterfactual path with an immutable feature."/></p><p>&lt;!– ## Domain constraints &amp;#10;In some cases, we may also want to constrain the domain of some feature. For example, age as a feature is constrained to a range from 0 to some upper bound corresponding perhaps to the average life expectancy of humans. Below, for example, we impose an upper bound of <span>$0.5$</span> for our two features. &amp;#10;```{.julia} counterfactual<em>data.mutability = [:both, :both] counterfactual</em>data.domain = [(0,0) for var in counterfactual<em>data.features</em>continuous]</p><pre><code class="nohighlight hljs">&amp;#10;This results in the counterfactual path shown below: since features are not allowed to be perturbed beyond the upper bound, the resulting counterfactual falls just short of the threshold probability $\gamma$.
&amp;#10;```{.julia}
ce = generate_counterfactual(x, target, counterfactual_data, M, generator)
plot(ce)</code></pre><p>–&gt;</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../whistle_stop/">« Whiste-Stop Tour</a><a class="docs-footer-nextpage" href="../data_catalogue/">Data Catalogue »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Sunday 24 March 2024 07:54">Sunday 24 March 2024</span>. Using Julia version 1.10.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
