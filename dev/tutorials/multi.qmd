```@meta
CurrentModule = CounterfactualExplanations 
```

# Counterfactuals for multi-class targets

In the existing literature counterfactual explanations have typically been applied in the binary classification setting [@verma2020counterfactual]. Research on algorithmic recourse in particular typically involves real-world datasets with an obvious target class - e.g. individual receives credit - and an adverse outcome - e.g. individual is denied loan [@karimi2020survey]. Still, counterfactual explanations are very much also applicable in the multi-class setting. In this tutorial we will go through an illustrative example involving the toy dataset shown in @fig-multi below.

```{julia}
#| echo: false
using Pkg; Pkg.activate("docs")
using Flux, Random, Plots, CounterfactualExplanations, Statistics
theme(:wong)
include("docs/src/utils.jl") # some plotting functions
www_path = "docs/src/tutorials/www"
```

```{julia}
using CounterfactualExplanations.Data
N = 200
counterfactual_data = load_blobs(N; centers=4, cluster_std=0.25)
```

```{julia}
#| echo: false
plt = plot()
plt = scatter!(counterfactual_data)
savefig(plt, joinpath(www_path, "multi_samples.png"))
```

![Synthetic dataset containing four different classes.](www/multi_samples.png){#fig-multi}

## Classifier

```{julia}
using CounterfactualExplanations.Models
M = fit_model(counterfactual_data, :MLP)
```

```{julia}
#| echo: false
plt = plot(M, counterfactual_data)
savefig(plt, joinpath(www_path, "multi_contour.png"))
```


@fig-multi-contour shows the resulting class probabilities in the two-dimensional feature domain.

![Class probabilities for MLP.](www/multi_contour.png){#fig-multi-contour}

# Generating counterfactuals

We randomly select an individual sample from any class and choose any of the remaining classes as our target at random.

```{julia}
# Randomly selected factual:
# Random.seed!(123)
X = counterfactual_data.X
x = select_factual(counterfactual_data, rand(1:size(X)[2])) 
y = predict_label(M, counterfactual_data, x)
target = rand(unique(ys)[1:end .!= y]) # opposite label as target
```

Generic counterfactual search can then be implemented as follows. The only difference to the binary setting is that we need to declare `logitcrossentropy` as the loss function for the counterfactual search. @fig-multi-generic shows the resulting counterfactual path.

```{julia}
# Define generator:
generator = GenericGenerator()
# Generate recourse:
ce = generate_counterfactual(x, target, counterfactual_data, M, generator)
```

```{julia}
#| echo: false
using CounterfactualExplanations.Counterfactuals: animate_path
anim = animate_path(counterfactual, plot_proba=true, size=(800,350))
gif(anim, joinpath(www_path, "multi_generic_recourse.gif"), fps=round(total_steps(counterfactual)/5))
```

![Counterfactual path for generic generator.](www/multi_generic_recourse.gif){#fig-multi-generic}

## Deep ensemble

Staying consistent with previous tutorial we will also briefly look at the Bayesian setting. To incorporate uncertainty we use a simple deep ensemble instead of a single MLP.

```{julia}
ensemble = build_ensemble(5;kw=kw)
ensemble, = forward(ensemble, data, opt, n_epochs=epochs, plot_loss=false)
```

As before, we need to subtype and disptach:

```{julia}
import CounterfactualExplanations.Models: logits, probs
# Step 1)
struct FittedEnsemble <: Models.AbstractDifferentiableModel
    ensemble::AbstractArray
end

# Step 2)
using Statistics
logits(M::FittedEnsemble, X::AbstractArray) = selectdim(mean(Flux.stack([nn(X) for nn in M.ensemble],3), dims=3),3,1)
probs(M::FittedEnsemble, X::AbstractArray) = selectdim(mean(Flux.stack([softmax(nn(X)) for nn in M.ensemble],3),dims=3),3,1)

M=FittedEnsemble(ensemble)
```

```{julia}
#| echo: false
plt = plot(M,counterfactual_data)
savefig(plt, joinpath(www_path, "multi_ensemble_contour.png"))
```

@fig-multi-ensemble-contour shows the resulting class probabilities.

![Class probabilities for deep ensemble.](www/multi_ensemble_contour.png){#fig-multi-ensemble-contour}

For the greedy recourse generator we also specify `logitcrossentropy` as our loss function and modify the hyperparameters slightly. @fig-greedy shows the resulting counterfactual path.

```{julia}
generator = GreedyGenerator(loss=:logitcrossentropy,Î´=0.25,n=30)
counterfactual = generate_counterfactual(x, target, counterfactual_data, M, generator)
```

```{julia}
#| echo: false
anim = animate_path(counterfactual, plot_proba=true, size=(800,350))
gif(anim, joinpath(www_path, "multi_greedy_recourse.gif"), fps=round(total_steps(counterfactual)/5))
```

![Counterfactual path for greedy generator.](www/multi_greedy_recourse.gif){#fig-greedy}

# References