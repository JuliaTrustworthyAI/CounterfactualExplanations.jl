# Added Features to CounterfactualExplanations.jl

In this notebook, we document the new features that we have added to the CounterfactualExplanations.jl package. These features include adding new counterfactual generators into the package, increasing the scope of predictive models that are compatible with the package, adding unit testing and documentation, and improving the package infrastructure. We hope that this notebook will serve as a useful reference for both ourselves and the course staff.

# Setup

```{julia}
using Pkg
Pkg.activate("students_documentation/summary_notebook")
    
# Dependencies
using Revise
using CounterfactualExplanations
using Images
using MLDatasets
using Tidier
using PythonCall
using Random
```

## Must haves

### Added Datasets

#### Statlog German credit dataset

Added Statlog German credit as a benchmark dataset.

```{julia}
german_credit_data = CounterfactualExplanations.Data.load_german_credit()
german_credit_data_x = german_credit_data.X
german_credit_data_y = german_credit_data.output_encoder.y
```

##### Post Hoc benchmarking with Statlog German credit dataset

```{julia}
# Train a model
M = fit_model(german_credit_data, :Linear)

# Factual and target labels:
target = 1
factual = 0
```

```{julia}
n_individuals = 5

# Choose random factual individuals
ids = rand(findall(predict_label(M, german_credit_data) .== factual), n_individuals)
xs = select_factual(german_credit_data, ids)

generator = GenericGenerator()

generated_counterfactuals_german_credit_data = generate_counterfactual(
    xs,
    target,
    german_credit_data,
    M, 
    generator; 
    num_counterfactuals=1
)
```

```{julia}
benchmark_german_credit_data = CounterfactualExplanations.Evaluation.benchmark(generated_counterfactuals_german_credit_data)

@chain benchmark_german_credit_data() begin
    @filter(variable == "distance")
    @select(sample, variable, value)
end
```

```{julia}
factual_datapoint = first(xs)[1]
counterfactual_datapoint = generated_counterfactuals_german_credit_data[1].sâ€²

df = DataFrame(Vector1 = vec(factual_datapoint), Vector2 = vec(counterfactual_datapoint))
```

### Interface to Python models

The interface supports generating counterfactuals for any neural network that has been previously defined and trained using PyTorch, regardless of the specific architectural details of the model.

##### Load the data
```{julia}
# Load data
Random.seed!(42);
N = 100

counterfactual_data = CounterfactualExplanations.Data.load_moons(N)
```

##### Load the saved PyTorch model

Since the package provides support for PyTorch models predefined by the user rather than for training PyTorch models inside the package as was requested by the client, the user has to provide a path to the model definition and a path to the model weights as input. This can be done through the following method:

```{julia}
model_loaded = CounterfactualExplanations.Models.pytorch_model_loader(
    "$(pwd())/students_documentation/summary_notebook/miscellaneous",
    "neural_network_class",
    "NeuralNetwork",
    "$(pwd())/students_documentation/summary_notebook/miscellaneous/pretrained_model.pt"
)

model_pytorch = CounterfactualExplanations.Models.PyTorchModel(model_loaded, :classification_multi)
```

The four arguments of `pytorch_model_loader()` are the following:
1. `model_path`: the path to the folder with a `.py` file where the PyTorch model is defined
2. `model_file`: the name of the `.py` file where the PyTorch model is defined
3. `class_name`: The name of the class of the PyTorch model
4. `pickle_path`: The path to the Pickle file that holds the model weights

After importing the model in this way, counterfactuals can be created for a PyTorch model the same way as for any other model.

##### Select a factual and generate counterfactuals for it like with any other model
```{julia}
Random.seed!(42)

target = 0
factual = 1

@info "Choose factual's index"
y_chosen_factual_idx = rand(findall(CounterfactualExplanations.Models.predict_label(model_pytorch, counterfactual_data) .== factual))

@info "Select factual"
x_random_factual = select_factual(counterfactual_data, y_chosen_factual_idx)
```

```{julia}
# Define a generator:
generator = CounterfactualExplanations.Generators.GenericGenerator()

@info "Generate counterfactual_pytorch"
counterfactual_pytorch = CounterfactualExplanations.generate_counterfactual(
    x_random_factual, 
    target, 
    counterfactual_data, 
    model_pytorch, 
    generator;
    max_iter=1000
)

CounterfactualExplanations.plot(counterfactual_pytorch; title = "model_pytorch path")
```

Alternatively, it is also possible to define a brand new PyTorch model.

### <feature_name>

<feature_description>

```{julia}
print("Hello world!")
```

## Should haves

### Added Datasets

#### CIFAR10 dataset

Added CIFAR10 from MLDatasets.jl as a benchmark dataset.

```{julia}
cifar_10_data = CounterfactualExplanations.Data.load_cifar_10()
cifar_10_x = cifar_10_data.X
cifar_10_y = cifar_10_data.output_encoder.y
```

```{julia}
images = []

for i in 0:9
    ys = findall(cifar_10_y .== i)
    for j in 0:9
        x = cifar_10_x[:,rand(ys)]

        x = clamp.((x .+ 1.0) ./ 2.0, 0.0, 1.0) |>
            x -> reshape(x, 32, 32, 3) |>
            x -> convert2image(CIFAR10, x)
        push!(images, x)
    end
end

mosaic(images..., ncol=10) |> display
```

### <feature_name>

<feature_description>

```{julia}
print("Hello world!")
```

## Could haves

### <feature_name>

<feature_description>

```{julia}
print("Hello world!")
```
